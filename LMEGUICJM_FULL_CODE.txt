*class lcl_catalog DEFINITION DEFERRED.
*---------------------------------------------------------------------*
*       CLASS lcl_req_item_table IMPLEMENTATION
*---------------------------------------------------------------------*
CLASS lcl_req_item_table   IMPLEMENTATION.

*----------------------------------------------------------------------*
  METHOD constructor.

    CALL METHOD super->constructor
      EXPORTING
        im_dynpro      = im_dynpro
        im_prog        = im_prog
        im_struct_name = im_struct_name
        im_priority    = im_priority.

    my_document_view = im_document_view.
    SET HANDLER on_event_double_click FOR me.

    DATA: fw TYPE REF TO cl_framework_mm,
          l_objecttype TYPE string40.
    CALL METHOD cl_framework_mm=>get_instance
      IMPORTING
        ex_instance = fw.
    l_objecttype = if_purchase_requisition=>c_objtyp.
    my_item_proposer ?= fw->get_proposer( l_objecttype ).

    my_converter = lcl_converter=>get_instance( ).

    DATA: l_info TYPE icont-quickinfo.
    l_info = text-905.
    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name   = icon_led_red
        info   = l_info
      IMPORTING
        result = my_icon_led_red
      EXCEPTIONS
        OTHERS = 0.

    l_info = text-906.
    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name   = icon_led_yellow
        info   = l_info
      IMPORTING
        result = my_icon_led_yellow
      EXCEPTIONS
        OTHERS = 0.

  ENDMETHOD.                    "constructor

*----------------------------------------------------------------------*

  METHOD if_model_holder_mm~get_model.
    re_model ?= my_current_model.
  ENDMETHOD.                    "if_model_holder_mm~get_model

*----------------------------------------------------------------------*

  METHOD if_multiple_model_holder_mm~set_current_model.

    mmpur_begin_mutex current_item_handle.

    my_current_model ?= im_model.

    RAISE EVENT if_subject_mm~changed.

    mmpur_end_mutex current_item_handle.

  ENDMETHOD. "if_multiple_model_holder_mm~set_current_model

*----------------------------------------------------------------------*

  METHOD if_multiple_model_holder_mm~next.

    DATA: wa      LIKE LINE OF items,
          l_index TYPE sy-tabix,
          l_lines  TYPE i,                                  "542320
          lt_items TYPE mmpur_requisition_items,            "542320
          ls_item  LIKE LINE OF lt_items,                   "542320
          l_req    TYPE REF TO if_purchase_requisition.     "542320

    CHECK NOT my_current_model IS INITIAL.

    READ TABLE items WITH KEY model = my_current_model
         TRANSPORTING NO FIELDS.
    IF NOT sy-subrc IS INITIAL.                             "542320
      DESCRIBE TABLE items LINES l_lines.                   "542320
      IF l_lines EQ 0.                                      "542320
*  table items empty -> item tab has never been opened yet, "542320
*  so get the items and set the index to the next one to read "542320
        mmpur_dynamic_cast l_req my_model.                  "542320
        IF NOT l_req IS INITIAL.                            "542320
          lt_items = l_req->get_items( im_auth_check = mmpur_yes ). "542320
          LOOP AT lt_items INTO ls_item.                    "542320
            wa-model ?= ls_item-item.                       "542320
            IF wa-model = my_current_model.                 "542320
              l_index = sy-tabix + 1.                       "542320
              EXIT.                                         "542320
            ENDIF.                                          "542320
          ENDLOOP.                                          "542320
          READ TABLE lt_items INTO ls_item INDEX l_index.   "542320
          wa-model ?= ls_item-item.                         "542320
        ENDIF.                                              "542320
      ENDIF.                                                "542320
    ELSE.                                                   "542320
      l_index = sy-tabix + 1.
      READ TABLE items INTO wa INDEX l_index.
    ENDIF.                                                  "542320
    IF sy-subrc IS INITIAL.

      CALL METHOD if_multiple_model_holder_mm~set_current_model(
        wa-model ).
    ENDIF.
  ENDMETHOD.                    "if_multiple_model_holder_mm~next

*----------------------------------------------------------------------*

  METHOD if_multiple_model_holder_mm~previous.

    DATA: wa      LIKE LINE OF items,
          l_index TYPE sy-tabix,
          l_previous LIKE LINE OF items,                    "542320
          l_lines  TYPE i,                                  "542320
          lt_items TYPE mmpur_requisition_items,            "542320
          ls_item  LIKE LINE OF lt_items,                   "542320
          l_req    TYPE REF TO if_purchase_requisition.     "542320


    CHECK NOT my_current_model IS INITIAL.

    READ TABLE items WITH KEY model = my_current_model
         TRANSPORTING NO FIELDS.
    IF NOT sy-subrc IS INITIAL.                             "542320
      DESCRIBE TABLE items LINES l_lines.                   "542320
      IF l_lines EQ 0.                                      "542320
*  table items empty -> item tab has never been opened yet, "542320
*  so get the items and save the previous one to retrieve   "542320
        mmpur_dynamic_cast l_req my_model.                  "542320
        IF NOT l_req IS INITIAL.                            "542320
          lt_items = l_req->get_items( im_auth_check = mmpur_yes ). "542320
          LOOP AT lt_items INTO ls_item.                    "542320
            wa-model ?= ls_item-item.                       "542320
            IF wa-model = my_current_model.                 "542320
              wa-model = l_previous-model.                  "542320
              EXIT.                                         "542320
            ELSE.                                           "542320
              l_previous-model = wa-model.                  "542320
            ENDIF.                                          "542320
          ENDLOOP.                                          "542320
          CHECK NOT wa-model IS INITIAL.                    "542320
        ENDIF.                                              "542320
      ENDIF.                                                "542320
    ELSE.                                                   "542320
      l_index = sy-tabix - 1.
      CHECK l_index GE 1.
      READ TABLE items INTO wa INDEX l_index.
    ENDIF.                                                  "542320

    IF sy-subrc IS INITIAL.

      CALL METHOD if_multiple_model_holder_mm~set_current_model(
        wa-model ).
    ENDIF.
  ENDMETHOD.                    "if_multiple_model_holder_mm~previous

*----------------------------------------------------------------------*

  METHOD pbo.

    CALL METHOD transport_from_model( my_model ).

    CALL METHOD get_proposer_data.

    CLEAR my_fs_model.                 "fieldselection buffer

    CALL METHOD super->pbo.

  ENDMETHOD.                    "pbo

*----------------------------------------------------------------------*
  METHOD set_model.

    DATA: l_header TYPE REF TO if_purchase_requisition,
          l_aktyp  TYPE aktyp.

    CLEAR my_fs_model.
    my_release_filter_on = mmpur_no.

    CALL METHOD super->set_model( im_model = im_model ).

    mmpur_dynamic_cast l_header im_model.
    CHECK NOT l_header IS INITIAL.

    l_aktyp = l_header->get_activity( ).

    IF l_aktyp EQ hin OR l_aktyp EQ ver.
      my_model_changeable = mmpur_yes.
    ELSE.
      my_model_changeable = mmpur_no.
    ENDIF.

  ENDMETHOD.                    "set_model
*----------------------------------------------------------------------*
  METHOD set_cursor.

    DATA: l_fieldlist LIKE im_fieldlist,
          l_field     LIKE LINE OF l_fieldlist.

    LOOP AT im_fieldlist INTO l_field.
* remapping of specific metafields
      CASE l_field.
        WHEN mmmfd_vendor.
          l_field = mmmfd_fixed_vend.
      ENDCASE.
      APPEND l_field TO l_fieldlist.
    ENDLOOP.

    CALL METHOD super->set_cursor
      EXPORTING
        im_model     = im_model
        im_container = im_container
        im_fieldlist = l_fieldlist.

  ENDMETHOD.                    "set_cursor
*----------------------------------------------------------------------*
  METHOD can_accept.

    DATA: l_model TYPE REF TO if_purchase_requisition_item.

    mmpur_dynamic_cast l_model im_model.
    IF l_model IS INITIAL.
      RAISE cannot_accept.
    ENDIF.

  ENDMETHOD.                    "can_accept

*----------------------------------------------------------------------*

  METHOD   transport_to_dynp.

    DATA: l_item            TYPE REF TO if_purchase_requisition_item,
          l_item_data_entry LIKE LINE OF item_data_pbo,
          l_mereq_item      TYPE mereq_item.
* Transport

    CLEAR l_item_data_entry.
    CLEAR mereq3211.

    mmpur_dynamic_cast l_item im_model.
    IF NOT l_item IS INITIAL.

      IF filter_description[] IS INITIAL AND
         sort_description[] IS INITIAL.

        l_mereq_item = l_item->get_data( ).

        CALL METHOD conversions_output
          EXPORTING
            im_item = l_mereq_item
          IMPORTING
            ex_data = l_item_data_entry.

        l_item_data_entry-model = l_item.
        APPEND l_item_data_entry TO item_data_pbo.

      ELSE.

        READ TABLE item_data_pbo INTO l_item_data_entry WITH KEY
                   model = l_item.

      ENDIF.

* conversions ------------------------------------------------------*

* deletion indicator
      CALL METHOD my_converter->convert_loekz_output
        EXPORTING
          im_loekz  = l_item_data_entry-data-loekz
        IMPORTING
          ex_status = l_item_data_entry-data-statusicon.
* textflagicon
* it is always set, but the fieldselection switches it off/on
      l_item_data_entry-data-textflag = 'X' .               "664320
* process state
      CALL METHOD my_converter->convert_banpricon_output
        EXPORTING
          im_banpr     = l_item_data_entry-data-banpr
          im_obj       = l_item
        IMPORTING
          ex_banpricon = l_item_data_entry-data-banpricon.

    ELSE.
      IF NOT my_item_proposer IS INITIAL AND
         my_model_changeable EQ mmpur_yes.
        CALL METHOD conversions_output
          EXPORTING
            im_item = my_proposed_item
          IMPORTING
            ex_data = l_item_data_entry.
      ENDIF.

    ENDIF.

    MOVE-CORRESPONDING l_item_data_entry-data TO mereq3211.

  ENDMETHOD.                    "transport_to_dynp

*----------------------------------------------------------------------*
  METHOD transport_from_model.

    DATA: l_req             TYPE REF TO if_purchase_requisition,
          lt_items          TYPE mmpur_requisition_items,
          ls_item           LIKE LINE OF lt_items,
          l_item            TYPE REF TO if_purchase_requisition_item,
          l_models_entry    LIKE LINE OF items,
          l_item_data_entry LIKE LINE OF item_data_pbo,
          lv_archived       TYPE mmpur_bool.                "967951

    mmpur_dynamic_cast l_req im_model.

    IF NOT l_req IS INITIAL.

      lt_items = l_req->get_items( im_auth_check = mmpur_yes
                                   im_release_op = my_release_filter_on ).
      CLEAR items.
      LOOP AT lt_items INTO ls_item.
        l_models_entry-model ?= ls_item-item.
        APPEND l_models_entry TO items.
      ENDLOOP.

      REFRESH item_data_pbo.
      REFRESH item_data_pai.
* check for archived document
      lv_archived = l_req->is_archived( ).                  "967951
      IF NOT filter_description[] IS INITIAL OR
         NOT sort_description[] IS INITIAL.
* we have to get all data in the case of an active filter or
* an active sort function. If both functions are inactive,
* data are read during transport_to_dynp
        LOOP AT items INTO l_models_entry.

          l_item ?= l_models_entry-model.
          my_item = l_item->get_data( ).
* set archived indicator for switching the displayed icon
          IF lv_archived EQ cl_mmpur_constants=>yes.        "967951
            my_item-loekz = cl_mmpur_constants=>archived.
          ENDIF.

          CALL METHOD conversions_output
            EXPORTING
              im_item = my_item
            IMPORTING
              ex_data = l_item_data_entry.

          l_item_data_entry-model = l_item.
          APPEND l_item_data_entry TO item_data_pbo.

        ENDLOOP.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "transport_from_model

*----------------------------------------------------------------------*

  METHOD transport_to_model.

    DATA: l_item TYPE REF TO if_purchase_requisition_item,
          l_header TYPE REF TO if_purchase_requisition,
          l_item_data_pbo LIKE LINE OF item_data_pbo,
          l_item_data_pai LIKE LINE OF item_data_pai,
          l_data_pbo       TYPE mereq3211,
          l_data_pai       TYPE mereq3211.

    CHECK NOT im_model IS INITIAL.

    l_item ?= im_model.
    l_header = l_item->get_requisition( ).

    my_item = l_item->get_data( ).

    READ TABLE item_data_pbo INTO l_item_data_pbo
              WITH KEY model = l_item.
    IF sy-subrc NE 0 AND
       NOT my_item_proposer IS INITIAL AND
       my_model_changeable EQ mmpur_yes.

      CALL METHOD conversions_output
        EXPORTING
          im_item = my_proposed_item
        IMPORTING
          ex_data = l_item_data_pbo.

    ENDIF.

    READ TABLE item_data_pai INTO l_item_data_pai
              WITH KEY model = l_item.
    CHECK sy-subrc IS INITIAL.

    DATA: l_itemx TYPE mereq_itemx.
    l_itemx = l_item->get_datax( ).
    MOVE-CORRESPONDING l_item_data_pbo-data TO l_data_pbo.
    MOVE-CORRESPONDING l_item_data_pai-data TO l_data_pai.
    mmpur_transport_fields_x l_data_pai
                             l_data_pbo
                             my_item
                             l_itemx.

    IF l_data_pbo-eeind NE l_data_pai-eeind.                "646686
      l_itemx-lfdat = mmpur_yes.
    ENDIF.

    CALL METHOD l_item->set_data( my_item ).
    CALL METHOD l_item->set_datax( l_itemx ).

  ENDMETHOD.                    "transport_to_model

*----------------------------------------------------------------------*

  METHOD build_dynpro_fields.

    DATA: l_dynpro_field LIKE LINE OF my_dynpro_fields.

    CALL METHOD super->build_dynpro_fields.

* special rules
    mmpur_dynprofield_set_option 'MEREQ3211-TEXTFLAG' '' 'X' 'X'.
    mmpur_dynprofield_set_option 'MEREQ3211-REF_BNFPO' '' 'X' ''.
    mmpur_dynprofield_set_option 'MEREQ3211-BNFPO' '' 'X' ''.
    mmpur_dynprofield_set_option 'MEREQ3211-MENGE' '' 'X' ''.

*functions
    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_delete_item.
    l_dynpro_field-screenname = 'DELETE'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_unlock_item.
    l_dynpro_field-screenname = 'UNLOCK'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    mmpur_build_metafield 'ITEMCOPY' mmmfd_item_copy.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_mass_change.
    l_dynpro_field-screenname = 'SCHNELLAEND'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_itemproposal.
    l_dynpro_field-screenname = 'ITEMPROPOSAL'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_catalog.
    l_dynpro_field-screenname = 'CATALOG'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_serno_list.
    l_dynpro_field-screenname = 'SN_OVERVIEW'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_item_lnkdocs.
    l_dynpro_field-screenname = 'LNKDOCS'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_source_search.
    l_dynpro_field-screenname = 'SOURCEASSIGN'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR  l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_availability_check.
    l_dynpro_field-screenname = 'AVAILCHECK'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

    CLEAR l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_mat_search.
    l_dynpro_field-screenname = 'EXTENDED_MATERIAL_SEARCH'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

*DCM for pushbutton complete all on MEGUI 3211 TC
    CLEAR  l_dynpro_field.
    l_dynpro_field-metafield = mmmfd_dcm_complete_all.
    l_dynpro_field-screenname = 'DCMALL'.
    INSERT l_dynpro_field INTO TABLE my_dynpro_fields.

*remove some metafields
    DELETE my_dynpro_fields WHERE fieldname = 'TCSELFLAG'.
    DELETE my_dynpro_fields WHERE fieldname = 'STATUSICON'.

  ENDMETHOD.                    "build_dynpro_fields

*----------------------------------------------------------------------*
*   Filter Interface

  METHOD get_table_to_filter.
    DATA: lt_fieldcat TYPE lvc_t_fcat,
          ls_fieldcatalog_wa TYPE lvc_s_fcat.

    IF NOT item_data_pbo[] IS INITIAL.

      GET REFERENCE OF item_data_pbo[] INTO ch_table.

      CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
        EXPORTING
          i_buffer_active  = 'X'
          i_structure_name = 'MEREQ3211'
        CHANGING
          ct_fieldcat      = lt_fieldcat.

*
* Feldbeschreibung setzen
*
      LOOP AT lt_fieldcat INTO ls_fieldcatalog_wa.
*       ls_fieldcatalog_wa-ref_field = ls_fieldcatalog_wa-fieldname.
        CONCATENATE 'DATA-'
        ls_fieldcatalog_wa-fieldname INTO
        ls_fieldcatalog_wa-fieldname.

        IF ls_fieldcatalog_wa-datatype = 'CHAR'.
          ls_fieldcatalog_wa-lowercase = 'X'.
        ENDIF.

        ls_fieldcatalog_wa-seltext = ls_fieldcatalog_wa-scrtext_l.
        MODIFY lt_fieldcat FROM ls_fieldcatalog_wa.
      ENDLOOP.

      ex_fieldcatalog[] = lt_fieldcat[].

    ENDIF.

  ENDMETHOD.                    "get_table_to_filter

  METHOD get_selected_columns.

    DATA: ls_row_col LIKE LINE OF ex_row_col_table.

    CALL METHOD super->get_selected_columns
      IMPORTING
        ex_row_col_table = ex_row_col_table[].

    LOOP AT ex_row_col_table INTO ls_row_col.
      IF ls_row_col-fieldname EQ 'EEIND' AND                "636343
         im_for_sort EQ mmpur_yes.                          "636343
        ls_row_col-fieldname = 'LFDAT'.                     "636343
      ENDIF.                                                "636343

      CONCATENATE 'DATA-'
      ls_row_col-fieldname INTO ls_row_col-fieldname.

      MODIFY ex_row_col_table FROM ls_row_col.

    ENDLOOP.

  ENDMETHOD.                    "get_selected_columns

*-------------------------------------------------------------------

  METHOD select_detail.

    DATA: l_model TYPE REF TO if_model_mm,
          l_item  TYPE REF TO if_purchase_requisition_item.

    CALL METHOD get_current_item
      IMPORTING
        ex_model        = l_model
      EXCEPTIONS
        no_object_found = 1.

    IF sy-subrc EQ 0.
      mmpur_dynamic_cast l_item l_model.
    ENDIF.

    IF l_item IS INITIAL AND NOT my_current_model IS INITIAL.
      l_item ?= my_current_model.
    ENDIF.

    CHECK NOT l_item IS INITIAL.

    CALL METHOD if_multiple_model_holder_mm~set_current_model(
      l_item ).
  ENDMETHOD.                    "select_detail

*----------------------------------------------------------------------*

  METHOD transport_from_dynp.

    DATA: l_item TYPE REF TO if_purchase_requisition_item,
          l_items TYPE mmpur_requisition_items,
          l_header TYPE REF TO if_purchase_requisition,
          l_item_data_pbo LIKE LINE OF item_data_pbo,
          l_item_data_pai LIKE LINE OF item_data_pai,
          wa LIKE LINE OF l_items.

    CLEAR: l_item_data_pbo,
           l_item_data_pai.

    l_header ?= my_model.

    mmpur_dynamic_cast l_item im_model.
    IF NOT l_item IS INITIAL.

      READ TABLE item_data_pbo INTO l_item_data_pbo
                 WITH KEY model = l_item.
      IF sy-subrc NE 0.
        MESSAGE a816 WITH 'TRANSPORT_FROM_DYNP'.
      ENDIF.

    ELSE.

      IF NOT my_item_proposer IS INITIAL AND
         my_model_changeable EQ mmpur_yes.
        CALL METHOD conversions_output
          EXPORTING
            im_item = my_proposed_item
          IMPORTING
            ex_data = l_item_data_pbo.
      ENDIF.
    ENDIF.

    MOVE-CORRESPONDING mereq3211 TO l_item_data_pai-data.

* item number must be restored
    IF NOT l_item_data_pbo-data-bnfpo IS INITIAL.
      l_item_data_pai-data-bnfpo = l_item_data_pbo-data-bnfpo.
    ENDIF.

*- special cases ------------------------------------------------------*

    CLEAR: l_item_data_pai-data-statusicon,
           l_item_data_pai-data-textflag,
           l_item_data_pai-data-tcselflag.

    CLEAR: l_item_data_pai-data-banpricon.
    l_item_data_pai-data-banpr = l_item_data_pbo-data-banpr.

* 1. plant
    l_item_data_pai-data-werks = l_item_data_pbo-data-werks.
    IF l_item_data_pai-data-name1 NE l_item_data_pbo-data-name1.

      CALL METHOD my_converter->convert_plant
        CHANGING
          ch_werks = l_item_data_pai-data-werks
          ch_name  = l_item_data_pai-data-name1.
    ENDIF.
* deliv. plant
    l_item_data_pai-data-reswk = l_item_data_pbo-data-reswk.
    IF l_item_data_pai-data-resbz NE l_item_data_pbo-data-resbz.

      CALL METHOD my_converter->convert_plant
        CHANGING
          ch_werks = l_item_data_pai-data-reswk
          ch_name  = l_item_data_pai-data-resbz.

    ENDIF.
* 2. Storage location
    l_item_data_pai-data-lgort = l_item_data_pbo-data-lgort.
    IF l_item_data_pai-data-lgobe NE l_item_data_pbo-data-lgobe.

      CALL METHOD my_converter->convert_lgort
        CHANGING
          ch_werks = l_item_data_pai-data-werks
          ch_name  = l_item_data_pai-data-name1
          ch_lgort = l_item_data_pai-data-lgort
          ch_lgobe = l_item_data_pai-data-lgobe.

    ENDIF.
* 3. material group
    l_item_data_pai-data-matkl = l_item_data_pbo-data-matkl.

    IF l_item_data_pai-data-wgbez NE l_item_data_pbo-data-wgbez.

      CALL METHOD my_converter->convert_matkl
        CHANGING
          ch_matkl = l_item_data_pai-data-matkl
          ch_wgbez = l_item_data_pai-data-wgbez.

    ENDIF.

* 4. deletion indicator
    l_item_data_pai-data-loekz = l_item_data_pbo-data-loekz.

* 5. item category
    l_item_data_pai-data-pstyp = l_item_data_pbo-data-pstyp.
    IF l_item_data_pai-data-epstp NE l_item_data_pbo-data-epstp.
      CALL METHOD my_converter->convert_pstyp
        CHANGING
          ch_pstyp = l_item_data_pai-data-pstyp
          ch_epstp = l_item_data_pai-data-epstp.
    ENDIF.

* 6. Material number
    IF l_item_data_pai-data-matnr NE l_item_data_pbo-data-matnr AND
       l_item_data_pai-data-matnr NE space.
      CALL METHOD my_converter->convert_matnr
        CHANGING
          ch_matnr = l_item_data_pai-data-matnr.
    ENDIF.
    IF l_item_data_pai-data-ematn NE l_item_data_pbo-data-ematn AND
       l_item_data_pai-data-ematn NE space.
      CALL METHOD my_converter->convert_matnr
        CHANGING
          ch_matnr = l_item_data_pai-data-ematn.
    ENDIF.

* 7. Delivering Storage location
    l_item_data_pai-data-reslo = l_item_data_pbo-data-reslo.
    IF l_item_data_pai-data-reslo_bez NE l_item_data_pbo-data-reslo_bez.

      CALL METHOD my_converter->convert_lgort
        CHANGING
          ch_werks = l_item_data_pai-data-reswk
          ch_name  = l_item_data_pai-data-resbz
          ch_lgort = l_item_data_pai-data-reslo
          ch_lgobe = l_item_data_pai-data-reslo_bez.

    ENDIF.

* date has to be converted always
    CALL METHOD my_converter->convert_eindt
      CHANGING
        ch_lpein = l_item_data_pai-data-lpein
        ch_eindt = l_item_data_pai-data-lfdat
        ch_elpei = l_item_data_pai-data-elpei
        ch_eeind = l_item_data_pai-data-eeind.

* end of special cases

    IF l_item_data_pai-data NE l_item_data_pbo-data.
*
* hier neues Objekt gegebenenfalls instanziieren
      IF l_item IS INITIAL.

        IF l_item_data_pai-data-ref_banfn IS INITIAL.
          CLEAR l_item_data_pai-data-ref_bnfpo.
          l_item = l_header->create_item( ).
          CALL METHOD notify_data_changed( l_item ).
        ELSE.
          l_items = copy_with_reference(
                    im_banfn = l_item_data_pai-data-ref_banfn
                    im_bnfpo = l_item_data_pai-data-ref_bnfpo ).
          IF l_items IS INITIAL.
            IF l_item_data_pai-data-ref_bnfpo IS INITIAL.
              MESSAGE i051(06) WITH l_item_data_pai-data-ref_banfn.
            ELSE.
              MESSAGE i275(06) WITH l_item_data_pai-data-ref_banfn
                                    l_item_data_pai-data-ref_bnfpo.
            ENDIF.
            CLEAR l_item_data_pai-data-ref_banfn.
            CLEAR l_item_data_pai-data-ref_bnfpo.
          ELSE.
            LOOP AT l_items INTO wa.
              IF sy-tabix EQ 1.
                l_item = wa-item.
              ENDIF.
              CALL METHOD notify_data_changed( wa-item ).
            ENDLOOP.
          ENDIF.
        ENDIF.

* neue Instanz in die benötigten Tabellen schieben, um die Selektion
* bei neuen Positionen für den Katalog zu erhalten
        DATA l_models_entry LIKE LINE OF items.
        mmpur_dynamic_cast im_model l_item.
        l_models_entry-model ?= l_item.
        APPEND l_models_entry TO items.

      ELSE.
        CALL METHOD notify_data_changed( l_item ).
      ENDIF.
    ENDIF.

    l_item_data_pai-model = l_item.
    APPEND l_item_data_pai TO item_data_pai.

    CLEAR mereq3211.

  ENDMETHOD.                    "transport_from_dynp

*---------------------------------------------------------------------*

  METHOD transport_from_catalog.

    DATA: l_item            TYPE REF TO if_purchase_requisition_item,
          l_header          TYPE REF TO if_purchase_requisition,
          l_item_data_pbo   LIKE LINE OF item_data_pbo,
          l_item_data_pai   LIKE LINE OF item_data_pai,

          l_mereq_item      TYPE mereq_item,
          l_mereq_itemx     TYPE mereq_itemx,
          l_mereq_material  TYPE mereq3319,
          l_mereq_valuation TYPE mereq3320,
          l_mereq_quantity  TYPE mereq3321,
          l_mereq_source    TYPE mereq_source,

          l_change          TYPE c,
          l_data_changed    TYPE c,
          l_tabix           TYPE sy-tabix.
    DATA:  lv_mapval         TYPE oci_srv_map_info,
           lr_oci_srv_info   TYPE REF TO cl_oci_map_srv_info.

    l_header ?= my_model.

    mmpur_dynamic_cast l_item im_model.

    IF NOT l_item IS INITIAL.
      READ TABLE item_data_pbo INTO l_item_data_pbo
                 WITH KEY model = l_item.
    ENDIF.

    IF l_item_data_pbo IS INITIAL.
      IF NOT my_item_proposer IS INITIAL AND
         my_model_changeable EQ mmpur_yes.
        CALL METHOD conversions_output
          EXPORTING
            im_item = my_proposed_item
          IMPORTING
            ex_data = l_item_data_pbo.
      ENDIF.
    ENDIF.

    MOVE-CORRESPONDING im_item-data TO l_item_data_pai-data.

* item number must be restored
    IF NOT l_item_data_pbo-data-bnfpo IS INITIAL.
      l_item_data_pai-data-bnfpo = l_item_data_pbo-data-bnfpo.
    ENDIF.

*- special cases -----------------------------------------------------*

    CLEAR: l_item_data_pai-data-statusicon,
           l_item_data_pai-data-textflag,
           l_item_data_pai-data-tcselflag.

    CLEAR: l_item_data_pai-data-banpricon.
    l_item_data_pai-data-banpr = l_item_data_pbo-data-banpr.

* 1. plant
    l_item_data_pai-data-werks = l_item_data_pbo-data-werks.
    IF l_item_data_pai-data-name1 NE l_item_data_pbo-data-name1.

      CALL METHOD my_converter->convert_plant
        CHANGING
          ch_werks = l_item_data_pai-data-werks
          ch_name  = l_item_data_pai-data-name1.

    ENDIF.
* 2. deliv. plant
    l_item_data_pai-data-reswk = l_item_data_pbo-data-reswk.
    IF l_item_data_pai-data-resbz NE l_item_data_pbo-data-resbz.

      CALL METHOD my_converter->convert_plant
        CHANGING
          ch_werks = l_item_data_pai-data-reswk
          ch_name  = l_item_data_pai-data-resbz.

    ENDIF.
* 3. storage location
    l_item_data_pai-data-lgort = l_item_data_pbo-data-lgort.
    IF l_item_data_pai-data-lgobe NE l_item_data_pbo-data-lgobe.

      CALL METHOD my_converter->convert_lgort
        CHANGING
          ch_werks = l_item_data_pai-data-werks
          ch_name  = l_item_data_pai-data-name1
          ch_lgort = l_item_data_pai-data-lgort
          ch_lgobe = l_item_data_pai-data-lgobe.

    ENDIF.
* 4. material group
    l_item_data_pai-data-matkl = l_item_data_pbo-data-matkl.
    im_item-material-matkl     = l_item_data_pbo-data-matkl.

    IF l_item_data_pai-data-wgbez NE l_item_data_pbo-data-wgbez.

      CALL METHOD my_converter->convert_matkl
        CHANGING
          ch_matkl = l_item_data_pai-data-matkl
          ch_wgbez = l_item_data_pai-data-wgbez.

      im_item-data-matkl     = l_item_data_pai-data-matkl.
      im_item-data-wgbez     = l_item_data_pai-data-wgbez.
      im_item-material-matkl = l_item_data_pai-data-matkl.

    ENDIF.
* 5. deletion indicator
    l_item_data_pai-data-loekz = l_item_data_pbo-data-loekz.
* 6. item category
    l_item_data_pai-data-pstyp = l_item_data_pbo-data-pstyp.
    IF l_item_data_pai-data-epstp NE l_item_data_pbo-data-epstp.
      CALL METHOD my_converter->convert_pstyp
        CHANGING
          ch_pstyp = l_item_data_pai-data-pstyp
          ch_epstp = l_item_data_pai-data-epstp.

      im_item-data-pstyp = l_item_data_pai-data-pstyp.
      im_item-data-epstp = l_item_data_pai-data-epstp.

    ENDIF.
* 7. material number
    IF l_item_data_pai-data-matnr NE l_item_data_pbo-data-matnr AND
       l_item_data_pai-data-matnr NE space.
      CALL METHOD my_converter->convert_matnr
        CHANGING
          ch_matnr = l_item_data_pai-data-matnr.

      im_item-data-matnr     = l_item_data_pai-data-matnr.
      im_item-material-matnr = l_item_data_pai-data-matnr.

    ENDIF.
    IF l_item_data_pai-data-ematn NE l_item_data_pbo-data-ematn AND
       l_item_data_pai-data-ematn NE space.
      CALL METHOD my_converter->convert_matnr
        CHANGING
          ch_matnr = l_item_data_pai-data-ematn.

      im_item-data-ematn     = l_item_data_pai-data-ematn.
      im_item-material-ematn = l_item_data_pai-data-ematn.

    ENDIF.
* 8. delivering storage location
    l_item_data_pai-data-reslo = l_item_data_pbo-data-reslo.
    IF l_item_data_pai-data-reslo_bez NE l_item_data_pbo-data-reslo_bez.

      CALL METHOD my_converter->convert_lgort
        CHANGING
          ch_werks = l_item_data_pai-data-reswk
          ch_name  = l_item_data_pai-data-resbz
          ch_lgort = l_item_data_pai-data-reslo
          ch_lgobe = l_item_data_pai-data-reslo_bez.

    ENDIF.
* 9. date has to be converted always
    CALL METHOD my_converter->convert_eindt
      CHANGING
        ch_lpein = l_item_data_pai-data-lpein
        ch_eindt = l_item_data_pai-data-lfdat
        ch_elpei = l_item_data_pai-data-elpei
        ch_eeind = l_item_data_pai-data-eeind.

    im_item-data-lpein = l_item_data_pai-data-lpein.
    im_item-data-lfdat = l_item_data_pai-data-lfdat.
    im_item-data-elpei = l_item_data_pai-data-elpei.
    im_item-data-eeind = l_item_data_pai-data-eeind.
    im_item-quantity-lpein = l_item_data_pai-data-lpein.
    im_item-quantity-lfdat = l_item_data_pai-data-lfdat.

*- end of special cases ---------------------------------------------*

*- Changed or new item? ---------------------------------------------*
*   determine position in table item_data_pai
    IF NOT l_item IS INITIAL.
      READ TABLE item_data_pai WITH KEY model = l_item
                               TRANSPORTING NO FIELDS.
      l_tabix = sy-tabix.
    ELSE.
*     create a new instance for item generated from catalog
      CLEAR l_item_data_pai-data-ref_bnfpo.
      l_item = l_header->create_item( ).
    ENDIF.

*   item overview
    IF l_item_data_pai-data NE l_item_data_pbo-data.
      l_change = mmpur_yes.
    ENDIF.

    l_mereq_item = l_item->get_data( ).
    l_mereq_itemx = l_item->get_datax( ).

*   move-corresponding and set x-field with macro map_x
    DATA l_struct_descr TYPE REF TO cl_abap_structdescr.
    FIELD-SYMBOLS: <source>  TYPE any,
                   <target>  TYPE any,
                   <targetx> TYPE any,
                   <mapping> TYPE abap_compdescr.
    DEFINE map_x.
*     &1 - catalog data
*     &2 - object data
*     &3 - object datax
      l_struct_descr ?= cl_abap_structdescr=>describe_by_data( &1 ).
      loop at l_struct_descr->components assigning <mapping>.
        assign component <mapping>-name of structure &1 to <source>.
        check sy-subrc is initial.
        assign component <mapping>-name of structure &2 to <target>.
        check sy-subrc is initial.
        assign component <mapping>-name of structure &3 to <targetx>.
        check sy-subrc is initial.
        check <source> ne <target>.
        <target>  = <source>.
        <targetx> = mmpur_yes.
      endloop.
    END-OF-DEFINITION.

*   item detail screen: material
    MOVE-CORRESPONDING l_mereq_item TO l_mereq_material.
    IF l_mereq_material NE im_item-material.
      map_x im_item-material l_mereq_item l_mereq_itemx.
      l_change = mmpur_yes.
      l_data_changed = mmpur_yes.
    ENDIF.

*   item detail screen: valuation
    MOVE-CORRESPONDING l_mereq_item TO l_mereq_valuation.
    IF l_mereq_valuation NE im_item-valuation.
      map_x im_item-valuation l_mereq_item l_mereq_itemx.
      l_change = mmpur_yes.
      l_data_changed = mmpur_yes.
    ENDIF.

*   item detail screen: quantity and
    MOVE-CORRESPONDING l_mereq_item TO l_mereq_quantity.
    IF l_mereq_quantity NE im_item-quantity.
      map_x im_item-quantity l_mereq_item l_mereq_itemx.
      l_change = mmpur_yes.
      l_data_changed = mmpur_yes.
    ENDIF.

*   item detail screen: source
    MOVE-CORRESPONDING l_mereq_item TO l_mereq_source.
    IF l_mereq_source NE im_item-source.
      map_x im_item-source l_mereq_item l_mereq_itemx.
      l_change = mmpur_yes.
      l_data_changed = mmpur_yes.
    ENDIF.
    " Set packno and item ref in helper class
    IF im_item-packno IS NOT INITIAL AND
       cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.

      CALL METHOD cl_oci_map_srv_info=>get_instance
        RECEIVING
          rr_instance = lr_oci_srv_info.

      IF lr_oci_srv_info IS NOT INITIAL .

        lv_mapval-packno = im_item-packno.
        lv_mapval-ref    = l_item.

        CALL METHOD lr_oci_srv_info->set_mapval
          EXPORTING
            im_map_val = lv_mapval.

      ENDIF.


    ENDIF.
*   text handling
*   only text deletion is possible at this point, new and changed
*   texts will processed at event 'EXECUTE' because copy rules
    DATA: lr_text          TYPE REF TO if_longtexts_mm,
          l_type           TYPE mmpur_t_texttypes,
          ls_catalog_texts TYPE catalog_text_type.

    FIELD-SYMBOLS: <text> TYPE mmpur_textlines.

    IF NOT im_item-text IS INITIAL.
*     distinuish between insert and delete
      LOOP AT im_item-text ASSIGNING <text>.
        IF NOT <text>-tdline IS INITIAL.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF <text>-tdline IS INITIAL.
        IF NOT l_mereq_item-bnfpo IS INITIAL.
          mmpur_dynamic_cast lr_text l_item.
          IF lr_text IS BOUND.
*           get all available text types
            l_item->if_longtexts_mm~get_types(
                                 IMPORTING ex_texttypes = l_type ).
            IF NOT l_type[] IS INITIAL.
              READ TABLE l_type WITH KEY tdid = <text>-tdid
                                TRANSPORTING NO FIELDS.
              IF sy-subrc IS INITIAL.
                CALL METHOD lr_text->delete_text( <text>-tdid ).
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        ls_catalog_texts-objref  = l_item.
        ls_catalog_texts-lines   = im_item-text.
        APPEND ls_catalog_texts TO my_catalog_texts.
      ENDIF.
    ENDIF.

*- set data ----------------------------------------------------------*
    IF l_change EQ mmpur_yes.
      IF l_data_changed EQ mmpur_yes.
        CALL METHOD l_item->set_data( l_mereq_item ).
        CALL METHOD l_item->set_datax( l_mereq_itemx ).
      ENDIF.
      CALL METHOD notify_data_changed( l_item ).
      l_item_data_pai-model = l_item.
      IF NOT l_tabix IS INITIAL.
        MODIFY item_data_pai FROM l_item_data_pai INDEX l_tabix.
      ELSE.
        APPEND l_item_data_pai TO item_data_pai.
      ENDIF.
    ENDIF.

    CLEAR l_item_data_pai.

  ENDMETHOD.                    "transport_from_catalog

*---------------------------------------------------------------------*

  METHOD modify_screen.

* special logic for texticon column in table control, this column must
* be ready for input                                          HW 664320

    DATA: ls_dynpro_field  LIKE LINE OF my_dynpro_fields,
          l_fieldselection LIKE LINE OF my_fieldselection.

    READ TABLE my_dynpro_fields INTO ls_dynpro_field
        WITH TABLE KEY screenname = 'MEREQ3211-TEXTFLAG'
        TRANSPORTING metafield.

    IF sy-subrc IS INITIAL.
      READ TABLE my_fieldselection INTO l_fieldselection
          WITH TABLE KEY metafield = ls_dynpro_field-metafield.

      IF sy-subrc IS INITIAL AND
         l_fieldselection-fieldstatus EQ '-' OR
         l_fieldselection-fieldstatus EQ '*'.

        l_fieldselection-fieldstatus = '.'.

        MODIFY my_fieldselection
            INDEX sy-tabix
            FROM l_fieldselection
            TRANSPORTING fieldstatus.

      ENDIF.
    ENDIF.

    CALL METHOD super->modify_screen.

  ENDMETHOD.                    "modify_screen

*---------------------------------------------------------------------*

  METHOD fs_get.

    DATA: l_model          TYPE REF TO if_model_mm,
          l_requested_type TYPE string40.
    DATA: ls_fieldsel LIKE LINE OF my_fieldselection, " SSLOC
          lf_reslo_allowed TYPE c,
          ls_basic_cfg      TYPE wsdt_basic_cfg.

    IF NOT im_model IS INITIAL.
      l_model = im_model.
    ELSE.
      l_model = my_model.
      l_requested_type = if_purchase_requisition=>c_objtyp.
    ENDIF.
    IF l_model NE my_fs_model OR
      my_fs_model IS INITIAL.
      my_fs_model = l_model.
      CALL METHOD super->fs_get(
          im_model          = l_model
          im_requested_type = l_requested_type
          im_initiator      = im_initiator ).
    ENDIF.

    READ TABLE my_fieldselection INTO ls_fieldsel  " SSLOC
               WITH KEY metafield = mmmfd_suppl_store_loc.
    IF sy-subrc EQ 0.

* Check if the supplying storage location is allowed
      CALL FUNCTION 'ME_DELIV_STRG_LOC_ACTIVE'
        IMPORTING
          ef_del_strg_loc_act = lf_reslo_allowed.
      IF lf_reslo_allowed NE 'X'.

        ls_fieldsel-fieldstatus = '-'.
        MODIFY TABLE my_fieldselection FROM ls_fieldsel.
      ENDIF.
    ENDIF.
* check if external materila search is possible
    READ TABLE my_fieldselection INTO ls_fieldsel
               WITH KEY metafield = mmmfd_mat_search.
    IF sy-subrc EQ 0.
      ls_basic_cfg = cl_wsd_config=>read_mat_basic_config( i_app_name = cl_wsd_constants=>co_appl_purchase_order ).
      IF ls_basic_cfg-so_active IS INITIAL.
        ls_fieldsel-fieldstatus = '-'.
        MODIFY TABLE my_fieldselection FROM ls_fieldsel.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "fs_get
*----------------------------------------------------------------------*

  METHOD subject_changed.

    DATA: l_req       TYPE REF TO if_purchase_requisition,
          lt_items    TYPE mmpur_requisition_items,
          an_item     LIKE LINE OF lt_items.

    IF sender EQ my_document_view.

      l_req ?= my_document_view->get_model( ).

* first item

      IF NOT l_req IS INITIAL.

        lt_items = l_req->get_items( im_auth_check = mmpur_yes
                                     im_release_op = my_release_filter_on ).

        READ TABLE lt_items INTO an_item INDEX 1.

      ENDIF.

      my_current_model ?= an_item-item.

      CALL METHOD set_model( l_req ).

    ENDIF.

  ENDMETHOD.                    "subject_changed

*----------------------------------------------------------------------*
  METHOD fcode_finished.

    DATA: l_req    TYPE REF TO if_purchase_requisition,
          lt_items TYPE mmpur_requisition_items,
          an_item  LIKE LINE OF lt_items.

    CALL METHOD super->fcode_finished.

*- make sure the current item handle is set
    mmpur_dynamic_cast l_req my_model.
    CHECK NOT l_req IS INITIAL.

    IF my_current_model IS INITIAL.

      lt_items = l_req->get_items( im_auth_check = mmpur_yes
                                   im_release_op = my_release_filter_on ).

      READ TABLE lt_items INTO an_item INDEX 1.
      CALL METHOD if_multiple_model_holder_mm~set_current_model(
        an_item-item ).
    ENDIF.

  ENDMETHOD.                    "fcode_finished
*----------------------------------------------------------------------*
  METHOD pov_list.

    DATA: l_item         TYPE REF TO if_purchase_requisition_item,
          l_header       TYPE REF TO if_purchase_requisition,
          l_mereq_header TYPE mereq_header,
          l_mereq_item   TYPE mereq_item,
          l_mode         TYPE char1,
          l_mode2        TYPE char1,
          l_dynpro_entry LIKE LINE OF my_dynpro_fields.

    CHECK NOT im_metafield IS INITIAL.

* first we have to read data areas for header and item
    IF NOT my_model IS INITIAL.
      l_header ?= my_model.
      l_mereq_header = l_header->get_data( ).
    ELSE.
      CLEAR l_mereq_header.
    ENDIF.

    IF NOT im_model IS INITIAL.
      l_item ?= im_model.
      l_mereq_item = l_item->get_data( ).
    ELSE.
      CLEAR l_mereq_item.
    ENDIF.

* call help function

    CASE im_metafield.

* item category
      WHEN mmmfd_item_cat.

        CALL FUNCTION 'HELP_VALUES_EPSTP'
          EXPORTING
            program   = prog
            dynnr     = dynpro
            fieldname = 'MEREQ3211-EPSTP'
            bsart     = l_mereq_header-bsart
            bstyp     = l_mereq_header-bstyp
            mode      = im_mode
          EXCEPTIONS
            OTHERS    = 1.

* plant
      WHEN mmmfd_plant.
        DATA: h_werks LIKE mereq3211-werks.

        CALL FUNCTION 'HELP_VALUES_WERKS'
          EXPORTING
            i_program = prog
            i_dynnr   = dynpro
          IMPORTING
            e_werks   = h_werks
          EXCEPTIONS
            OTHERS    = 1.
        IF h_werks NE space.
          mereq3211-name1 = h_werks.
        ENDIF.

* deliv. plant
      WHEN mmmfd_suppl_plnt.

        CALL FUNCTION 'HELP_VALUES_WERKS'
          EXPORTING
            i_program = prog
            i_dynnr   = dynpro
          IMPORTING
            e_werks   = h_werks
          EXCEPTIONS
            OTHERS    = 1.
        IF h_werks NE space.
          mereq3211-resbz = h_werks.
        ENDIF.

* order unit
      WHEN mmmfd_unit.
        IF im_mode EQ 'D'.
          l_mode2 = '1'.
        ELSE.
          l_mode2 = ' '.
        ENDIF.
        CALL FUNCTION 'ME_VALUES_MEINS'
          EXPORTING
            program         = prog
            dynnr           = dynpro
            fieldname_matnr = 'MEREQ3211-MATNR'
            fieldname_meins = 'MEREQ3211-MEINS'
            mode            = l_mode2.

* delivery date category
      WHEN mmmfd_del_datcat.
        DATA: l_elpei LIKE mereq3211-elpei.
        CALL FUNCTION 'ME_VALUES_TPRG'
          IMPORTING
            e_lpein = l_elpei.
        IF l_elpei NE space.
          mereq3211-elpei = l_elpei.
        ENDIF.

* delivery date
      WHEN mmmfd_deliv_date.
        DATA: l_eeind LIKE mereq3211-eeind.
        CALL FUNCTION 'ME_VALUES_EEIND'
          EXPORTING
            i_progn = prog
            i_dynpn = dynpro
            i_stepl = im_line
            i_field = 'MEREQ3211-ELPEI'
          IMPORTING
            e_eeind = l_eeind
            e_lpein = l_elpei.
        IF l_eeind NE space.
          mereq3211-eeind = l_eeind.
        ENDIF.
        IF l_elpei NE space.
          mereq3211-elpei = l_elpei.
        ENDIF.

    ENDCASE.


  ENDMETHOD.                    "pov_list
*----------------------------------------------------------------------*
  METHOD read_from_catalog.

    DATA: lt_oci_item      TYPE mmpur_oci_cat_return_type_t,
          ls_oci_item      TYPE mmpur_oci_cat_return_type,
          lt_oci_longtext  TYPE wsi_oci_longtext_t,
          ls_oci_longtext  TYPE wsi_oci_longtext_s,
          ls_cat_item      TYPE item_catalog_data_type,
          ls_proposed_item TYPE item_catalog_data_type,
          ls_textline      TYPE mmpur_textlines,
          l_tdid           TYPE mmpur_textlines-tdid VALUE 'B01',
          l_new_item       TYPE mmpur_bool,
          l_header         TYPE REF TO if_purchase_requisition,
          l_header_data    TYPE mereq_header,
          l_item_data      TYPE mereq_item,
          l_tabix          TYPE sy-tabix,
          l_factor         TYPE p DECIMALS 3,

          ls_fs            LIKE LINE OF my_cat_fs,
          l_mfs            TYPE REF TO cl_mfs_mm,
          lt_cat_mapping   TYPE STANDARD TABLE OF mepo_s_metafield_mapping,
          l_map            LIKE LINE OF my_cat_mapping,
          l_map_error      TYPE mmpur_bool,

          l_badi           TYPE REF TO me_catalog_interface,
          lo_badi_cust     TYPE REF TO me_catalog_interface_cust,
          l_item_descr     TYPE REF TO cl_abap_structdescr,
          l_catalog_descr  TYPE REF TO cl_abap_structdescr,
          ls_map_fields    TYPE mecat_fieldmap,
          lt_map_fields    TYPE mecat_fieldmap_tab,
          l_actual_error   TYPE mmpur_bool.

    DATA: lt_oci_item_srv          TYPE mmpur_oci_cat_return_type_t,
           lv_packno                TYPE comsrv-packno,
           lv_logical_system_name   TYPE tbdls-logsys,
           lr_cl_mmbsi_cc_conv      TYPE REF TO cl_mmbsi_cc_conv,
           lv_contract_item         TYPE bbp_itemno,
           lv_erp_contract_item     TYPE ebelp,
           lv_srm_flag              TYPE abap_bool,
           lv_srm_contract_id       TYPE bbp_itemno,
           lv_srvmapkey             TYPE srvmapkey,
           lv_line                  TYPE i,
           lv_no_items              TYPE i,
           lt_process_srv           TYPE mmpur_oci_cat_return_type_t,
           ls_oci_srv_item          TYPE mmpur_oci_cat_return_type,
           lv_parent_new            TYPE wsi_oci_line.


    FIELD-SYMBOLS: <source>   TYPE any,
                   <target>   TYPE any,
                   <s_target> TYPE any,
                   <mapping>  TYPE abap_compdescr.

    "Get Logical System Name
    CALL FUNCTION 'OWN_LOGICAL_SYSTEM_GET'
      IMPORTING
        own_logical_system             = lv_logical_system_name
      EXCEPTIONS
        own_logical_system_not_defined = 1
        OTHERS                         = 2.

    DEFINE is_input_allowed.
*     &1 - destination field
*     lt_fs - lokal table fieldselection (metafield - fieldstatus)
*     my_cat_mapping - table fieldmapping (fieldname - metafield)
      read table my_cat_mapping into l_map
                                with key fieldname = &1.
      if sy-subrc is initial.
        read table my_cat_fs into ls_fs
                             with key metafield = l_map-metafield.
        if sy-subrc is initial.
          if not ( ls_fs-fieldstatus eq '+' or
                   ls_fs-fieldstatus eq '.' or
                   ls_fs-fieldstatus is initial ).
            sy-subrc = 1.
          endif.
        endif.
      endif.
    END-OF-DEFINITION.

    DEFINE map.
*     &1 - destination structure
*     &2 - destination field
*     &3 - source value
      is_input_allowed &2.
      if sy-subrc is initial.
        assign component &2 of structure &1 to <target>.
        if sy-subrc is initial.
          <target> = &3.
        endif.
      endif.
    END-OF-DEFINITION.

*- prepare proposal data for new items -------------------------------*
*   get proposed data for new items and ...
    READ TABLE im_item_table INTO ls_proposed_item
                             WITH KEY model = ls_cat_item-model.
*   ... delete entry for proposer from out_tab
    IF sy-tabix GT 0.
      DELETE im_item_table INDEX sy-tabix.
    ENDIF.

*- call catalog interface --------------------------------------------*
    TRY.
        CALL FUNCTION 'MMPUROCI_PRODUCT_SEARCH'
          EXPORTING
*           IMD_WEBSERVICE_ID =
            imd_bstyp        = 'B'
            imd_searchstring = ''
*           IMD_LIFNR        =
            imd_init_call    = mmpur_yes
          IMPORTING
            et_oci_items     = lt_oci_item
            et_oci_longtext  = lt_oci_longtext.
      CATCH cx_mmpur_not_found cx_mmpur_incorrect_customizing.
        RAISE illegal_call.
    ENDTRY.

    IF lt_oci_item IS INITIAL.
      REFRESH im_item_table.
      RAISE no_data_import.
    ENDIF.

    mmpur_dynamic_cast1 l_header me->my_model.
    l_header_data = l_header->get_data( ).

*  get mapping for fieldselection
    IF my_cat_mapping IS INITIAL.
      l_mfs = cl_mfs_mm=>get_instance( ).
      l_mfs->register( EXPORTING  im_application = 'MMPUR_PO_DOC'
                       EXCEPTIONS already_registered = 1
                                  failure            = 2 ).
      my_cat_mapping = l_mfs->lookup( im_application = 'MMPUR_PO_DOC'
                                      im_tabname     = 'MEREQ_ITEM' ).
      lt_cat_mapping = my_cat_mapping.
      l_mfs->register( EXPORTING  im_application = 'MMPUR_PO_VIEWS'
                       EXCEPTIONS already_registered = 1
                                  failure            = 2 ).
      my_cat_mapping = l_mfs->lookup( im_application = 'MMPUR_PO_VIEWS'
                                      im_tabname     = 'MEREQ3211' ).
      APPEND LINES OF my_cat_mapping TO lt_cat_mapping.
      SORT lt_cat_mapping.
      my_cat_mapping = lt_cat_mapping.
      LOOP AT my_cat_mapping INTO l_map.
        ls_fs-metafield = l_map-metafield.
        INSERT ls_fs INTO TABLE my_cat_fs.
      ENDLOOP.
    ENDIF.

*- mapping catalog values to req items -------------------------------*
    LOOP AT lt_oci_item INTO ls_oci_item.
      l_tabix = sy-tabix.                                   "1768759
      READ TABLE im_item_table INDEX l_tabix INTO ls_cat_item.
      IF NOT sy-subrc IS INITIAL.
        ls_cat_item = ls_proposed_item.
        l_new_item = mmpur_yes.
      ENDIF.

* -- Service structure download possible only for ehp5 ---------------*
      IF cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.
        CLEAR lv_no_items.
        CLEAR lt_process_srv.
        CLEAR lv_packno.

        IF ls_oci_item-item_type CA 'FRLOI'.                "1768759
          LOOP AT lt_oci_item INTO ls_oci_srv_item.
            lv_parent_new = ls_oci_srv_item-parent_id.

            IF lv_parent_new IS INITIAL.
              lv_no_items = lv_no_items + 1.
              IF lv_no_items > 1.
                EXIT.
              ELSE.
                INSERT ls_oci_srv_item INTO TABLE lt_process_srv. "1768759
                DELETE lt_oci_item WHERE line = ls_oci_srv_item-line.
              ENDIF.
            ELSE.
              INSERT ls_oci_srv_item INTO TABLE lt_process_srv. "1768759
              DELETE lt_oci_item WHERE line = ls_oci_srv_item-line.
            ENDIF.

          ENDLOOP.

          IF ( ls_oci_item-service = abap_true ) AND ( ls_oci_item-parent_id EQ 'NULL' ).

          ELSE.

            IF ls_oci_item-item_type CA 'LFI'.
              CONTINUE.
            ELSEIF ls_oci_item-item_type EQ 'O'.
              READ TABLE lt_oci_item WITH KEY item_type = 'R' line = ls_oci_item-parent_id TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CONTINUE.
              ENDIF.
              READ TABLE lt_oci_item WITH KEY item_type = 'O' line = ls_oci_item-parent_id TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CONTINUE.
              ENDIF.
            ENDIF.

          ENDIF.

* get account assignment category with consumption indic. unknown 1768759
          SELECT SINGLE knttp FROM t163k INTO ls_proposed_item-data-knttp
                     WHERE kzvbr = cl_mmpur_constants=>kzvbr_u.

          IF lines( lt_process_srv ) GT 1.
            CALL FUNCTION 'MS_OCI_ADD_SERVICE_STRUCTURE'
              EXPORTING
                iv_service_info_fill_type = '0'
                it_oci_srv_items          = lt_process_srv
                iv_glob_origin            = '1'
              IMPORTING
                ev_packno                 = lv_packno.
          ENDIF.

        ENDIF.

      ENDIF.

*     get fieldselection for whole item
      IF ls_cat_item-model IS INITIAL.
        CALL METHOD l_header->if_fieldselection_mm~fs_get(
          CHANGING
            ch_fieldselection = my_cat_fs ).
      ELSE.
        CALL METHOD ls_cat_item-model->if_fieldselection_mm~fs_get(
          CHANGING
            ch_fieldselection = my_cat_fs ).
      ENDIF.

*     BAdI 'ME_CATALOG_INTERFACE' to determine field mapping
      TRY.
          REFRESH lt_map_fields.
          GET BADI l_badi.
          l_item_descr ?= cl_abap_structdescr=>describe_by_data(
                                                 ls_cat_item ).
          l_catalog_descr ?= cl_abap_structdescr=>describe_by_data(
                                                    ls_oci_item ).
          CLEAR ls_map_fields.
          CALL BADI l_badi->map_cat_values
            EXPORTING
              im_bstyp                   = 'B'
              im_catalog_structure       = 'ls_oci_item'
              im_catalog_structure_descr = l_catalog_descr
              im_item_structure          = 'ls_cat_item'
              im_item_structure_descr    = l_item_descr
            IMPORTING
              ex_field_map               = lt_map_fields
            CHANGING
              ch_oci_item                = ls_oci_item.
        CATCH cx_badi_not_implemented.
*         nothing
      ENDTRY.

      GET BADI lo_badi_cust. "1768759
      CALL BADI lo_badi_cust->map_catalog_values
        EXPORTING
          iv_bstyp             = 'B'
          iv_catalog_structure = 'ls_oci_item'
          io_rtts_catalog      = l_catalog_descr
          iv_item_structure    = 'ls_cat_item'
          io_rtts_item         = l_item_descr
        CHANGING
          ct_field_map         = lt_map_fields
          ct_oci_item          = ls_oci_item.

*     service flag
      IF ls_oci_item-service EQ mmpur_yes OR ls_oci_item-item_type CA 'RO'.
        is_input_allowed 'EPSTP'.
        IF sy-subrc IS INITIAL.
          ls_cat_item-data-pstyp = cl_mmpur_constants=>pstyp_9.
          SELECT SINGLE epstp FROM t163y INTO ls_cat_item-data-epstp
                              WHERE pstyp EQ ls_cat_item-data-pstyp
                                AND spras EQ sy-langu.
        ENDIF.
      ENDIF.

*     item overview
      IF ls_cat_item-data-pstyp NE cl_mmpur_constants=>pstyp_9. "1768759
        map ls_cat_item-data 'MATNR' ls_oci_item-matnr.     "938797
        is_input_allowed 'MENGE'.
        IF sy-subrc IS INITIAL.
          CALL FUNCTION 'ME_MAP_CHAR_TO_PACK'
            EXPORTING
              im_pack = ls_cat_item-data-menge
            CHANGING
              ch_char = ls_oci_item-quantity
            EXCEPTIONS
              OTHERS  = 1.
          TRY.
              ls_cat_item-data-menge = ls_oci_item-quantity.
            CATCH cx_sy_conversion_error cx_sy_arithmetic_error.
*             Fehler bei Datenübernahme von &1 aus dem Katalog in das
*             Feld &2
              MESSAGE i765(me) WITH ls_oci_item-quantity 'MENGE'.
              l_map_error = mmpur_yes.
          ENDTRY.
        ENDIF.
        is_input_allowed 'MEINS'.
        IF sy-subrc IS INITIAL.
          IF NOT ls_oci_item-unit IS INITIAL.
            CALL FUNCTION 'UNIT_OF_MEASURE_ISO_TO_SAP'
              EXPORTING
                iso_code  = ls_oci_item-unit
              IMPORTING
                sap_code  = ls_cat_item-data-meins
              EXCEPTIONS
                not_found = 1
                OTHERS    = 2.
            IF sy-subrc <> 0.
              MESSAGE i851(me) WITH ls_oci_item-unit.
              l_map_error = mmpur_yes.
            ENDIF.
          ELSE.
            CLEAR ls_cat_item-data-meins.
          ENDIF.
        ENDIF.
      ENDIF.
      map ls_cat_item-data 'TXZ01' ls_oci_item-description.
      IF ls_cat_item-data-matnr IS INITIAL.
        map ls_cat_item-data 'WGBEZ' ls_oci_item-matgroup.
      ENDIF.

*     material MEPO1319
      map ls_cat_item-material 'IDNLF' ls_oci_item-vendormat.
      ls_cat_item-material-txz01 = ls_cat_item-data-txz01.

*     valuation MEREQ3320
      map ls_cat_item-valuation 'WAERS' ls_oci_item-currency.
      IF ls_cat_item-data-pstyp NE cl_mmpur_constants=>pstyp_9. "1768759
        is_input_allowed 'PREIS'.
        map ls_cat_item-valuation 'PREIS' ls_oci_item-price. "1768759
        IF ls_oci_item-priceunit IS INITIAL.
          ls_oci_item-priceunit = '1'.
        ENDIF.
        IF ls_oci_item-priceunit IS INITIAL.
          ls_oci_item-priceunit = '1'.
        ENDIF.
        map ls_cat_item-valuation 'PEINH' ls_oci_item-priceunit.
      ENDIF.

*     quantity MEREQ3321
      map ls_cat_item-quantity 'PLIFZ' ls_oci_item-leadtime.

*     source
      IF l_header_data-bsakz EQ 'T'.
        map ls_cat_item-source 'RESWK' ls_oci_item-vendor.
      ELSE.
        map ls_cat_item-source 'FLIEF' ls_oci_item-vendor.
      ENDIF.
      map ls_cat_item-source 'KONNR' ls_oci_item-contract.
      map ls_cat_item-source 'KTPNR' ls_oci_item-contract_item.
      map ls_cat_item-source 'INFNR' ls_oci_item-purchinfrec.
      map ls_cat_item-source 'EKORG' ls_oci_item-purchorg.

      " Ehp5 Catalog changes, the contract reference should be done only if the contract was uploaded
      " from the same system or belongs to a central contract that has been distributed to the current system
      IF cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.
        IF ls_cat_item-data-pstyp EQ cl_mmpur_constants=>pstyp_9. "1768759
          ls_proposed_item-packno = lv_packno.
          ls_cat_item-packno      = lv_packno.
        ENDIF.
        IF lr_cl_mmbsi_cc_conv IS INITIAL.
          lr_cl_mmbsi_cc_conv = cl_mmbsi_cc_conv=>get_instance( ).
        ENDIF.

        IF ls_oci_item-sld_sys_name <> lv_logical_system_name.

*          CLEAR ls_cat_item-data-konnr.
*          CLEAR ls_cat_item-data-ktpnr.

          lv_contract_item = ls_oci_item-contract_item.

          CALL METHOD lr_cl_mmbsi_cc_conv->check_is_srm_contract
            EXPORTING
              iv_contract_id      = ls_oci_item-contract
              iv_contract_item_id = lv_contract_item
            IMPORTING
              ev_srm_flag         = lv_srm_flag
              ev_srm_contract_id  = lv_srm_contract_id.

          IF lv_srm_flag EQ abap_true.

            map ls_cat_item-data 'SRM_CONTRACT_ID'  ls_oci_item-contract.
            map ls_cat_item-data 'SRM_CONTRACT_ITM' ls_oci_item-contract_item.

          ENDIF.

        ELSE.

          IF ls_oci_item-item_type NE 'R'.

*            CLEAR ls_cat_item-data-konnr.
*            CLEAR ls_cat_item-data-ktpnr.

            lv_srvmapkey = ls_oci_item-contract_item.

            CALL METHOD lr_cl_mmbsi_cc_conv->get_erp_cont_item_id
              EXPORTING
                iv_erp_contract_id      = ls_oci_item-contract
                iv_srvmapkey            = lv_srvmapkey
              IMPORTING
                ev_erp_contract_item_id = lv_erp_contract_item.

            map ls_cat_item-data 'KONNR' ls_oci_item-contract.
            map ls_cat_item-data 'KTPNR' ls_oci_item-contract_item.

          ENDIF.

        ENDIF.

      ENDIF.

*     extra field mapping based on BAdI
      LOOP AT lt_map_fields INTO ls_map_fields.
        l_actual_error = mmpur_no.
        TRANSLATE ls_map_fields TO UPPER CASE.           "#EC TRANSLANG
        CASE ls_map_fields-item_field.
          WHEN 'WERKS'. ls_map_fields-item_field = 'NAME1'.
          WHEN 'RESWK'. ls_map_fields-item_field = 'RESBZ'.
          WHEN 'LGORT'. ls_map_fields-item_field = 'LGOBE'.
          WHEN 'MATKL'. ls_map_fields-item_field = 'WGBEZ'.
          WHEN 'PSTYP'. ls_map_fields-item_field = 'EPSTP'.
          WHEN 'RESLO'. ls_map_fields-item_field = 'RESLO_BEZ'.
          WHEN 'NETPR'. CONTINUE.
        ENDCASE.
        IF cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.
          CASE ls_map_fields-catalog_field.
            WHEN 'CONTRACT'. CONTINUE.
            WHEN 'CONTRACT_ITEM'. CONTINUE.
          ENDCASE.
        ENDIF.
        ASSIGN COMPONENT ls_map_fields-catalog_field
               OF STRUCTURE ls_oci_item TO <source>.
        CHECK sy-subrc IS INITIAL.
        LOOP AT l_item_descr->components ASSIGNING <mapping>.
          ASSIGN COMPONENT <mapping>-name
                 OF STRUCTURE ls_cat_item TO <s_target>.
          CHECK sy-subrc IS INITIAL.
          ASSIGN COMPONENT ls_map_fields-item_field
                 OF STRUCTURE <s_target> TO <target>.
          CHECK sy-subrc IS INITIAL.
          TRY.
              CALL FUNCTION 'ME_MAP_CHAR_TO_PACK'
                EXPORTING
                  im_pack = <target>
                CHANGING
                  ch_char = <source>
                EXCEPTIONS
                  OTHERS  = 1.
              map <s_target> ls_map_fields-item_field <source>.
            CATCH cx_sy_conversion_error cx_sy_arithmetic_error.
*                 Fehler bei Datenübernahme von &1 aus dem Katalog
*                 in das Feld &2
              IF l_actual_error EQ mmpur_no.
                MESSAGE i765(me)
                  WITH <source> ls_map_fields-item_field.
                l_map_error = mmpur_yes.
                l_actual_error = mmpur_yes.
              ENDIF.
          ENDTRY.
        ENDLOOP.
      ENDLOOP.

*     text
      is_input_allowed 'ITEXT'.
      IF sy-subrc IS INITIAL.
        LOOP AT lt_oci_longtext INTO  ls_oci_longtext
                                WHERE line EQ ls_oci_item-line.
          ls_textline-tdobject  = 'EBAN'.
          ls_textline-tdid      = l_tdid.
          ls_textline-tdformat  = ls_oci_longtext-text_form.
          ls_textline-tdline    = ls_oci_longtext-text_line.
          APPEND ls_textline TO ls_cat_item-text.
        ENDLOOP.
      ENDIF.

      IF l_new_item EQ mmpur_no.
        MODIFY im_item_table FROM ls_cat_item INDEX l_tabix.
      ELSE.
        APPEND ls_cat_item TO im_item_table.
      ENDIF.
      CLEAR ls_cat_item.
    ENDLOOP.

    IF l_map_error EQ mmpur_yes.
      RAISE map_error.
    ENDIF.

  ENDMETHOD.                    "read_from_catalog
*----------------------------------------------------------------------*
  METHOD catalog_texts.

    DATA: ls_texts       TYPE mmpur_textlines,
          lr_text        TYPE REF TO if_longtexts_mm,
          l_type         TYPE mmpur_t_texttypes,
          l_badi         TYPE REF TO me_catalog_interface.

    FIELD-SYMBOLS: <item> TYPE catalog_text_type.

*- text handling ------------------------------------------------------*
    LOOP AT my_catalog_texts ASSIGNING <item>.
      mmpur_dynamic_cast lr_text <item>-objref.
      IF lr_text IS BOUND.
*       get all available text types
        <item>-objref->if_longtexts_mm~get_types(
                           IMPORTING ex_texttypes = l_type ).
        IF NOT l_type[] IS INITIAL.
          CLEAR ls_texts.
          GET BADI l_badi.
          CALL BADI l_badi->determine_text_id
            EXPORTING
              im_bstyp = 'B'
            IMPORTING
              ex_tdid  = ls_texts-tdid.
          IF ls_texts-tdid IS INITIAL.
            LOOP AT <item>-lines INTO ls_texts.
              EXIT.
            ENDLOOP.
          ENDIF.
          CALL METHOD lr_text->set_text(
            EXPORTING
              im_tdid      = ls_texts-tdid
              im_textlines = <item>-lines ).
        ENDIF.
      ENDIF.
    ENDLOOP.
    REFRESH my_catalog_texts.

  ENDMETHOD.                    "catalog_texts

*----------------------------------------------------------------------*
  METHOD serial_list.
    TYPES: BEGIN OF lty_documents,
             edokn TYPE edokn,
             edokp TYPE edokp,
             anzsn TYPE anzsn,
             matnr TYPE matnr,
             werks TYPE werks,
             etenr TYPE eeten,
             bstyp TYPE bstyp,
           END OF lty_documents.
    DATA: ls_selection   LIKE LINE OF selection,
          lt_selection   LIKE selection,
          ls_documents   TYPE lty_documents,
          lt_documents   TYPE TABLE OF lty_documents,
          l_item         TYPE REF TO if_purchase_requisition_item,
          l_header       TYPE REF TO if_purchase_requisition,
          l_mereq_item   TYPE mereq_item,
          l_mereq_header TYPE mereq_header.

    BREAK-POINT ID mmpur_serialno.
    CHECK cl_ops_switch_check=>mm_sfws_serno( ) EQ cl_mmpur_constants=>yes.
    me->get_selection( IMPORTING ex_models = lt_selection ).
    IF NOT lt_selection[] IS INITIAL.
      REFRESH lt_documents.
      LOOP AT lt_selection INTO ls_selection.
        mmpur_dynamic_cast l_item ls_selection-model.
        CHECK l_item IS BOUND.
        CALL METHOD l_item->get_data
          RECEIVING
            re_data = l_mereq_item.
        IF l_mereq_header-banfn IS INITIAL.
          CALL METHOD l_item->get_requisition
            RECEIVING
              re_requisition = l_header.
          CALL METHOD l_header->get_data
            RECEIVING
              re_data = l_mereq_header.
        ENDIF.
        ls_documents-edokn = l_mereq_header-banfn.
        ls_documents-edokp = l_mereq_item-bnfpo.
        ls_documents-anzsn = l_mereq_item-anzsn.
        ls_documents-matnr = l_mereq_item-matnr.
        ls_documents-werks = l_mereq_item-werks.
        ls_documents-bstyp = cl_mmpur_constants=>bstyp_b.
        APPEND ls_documents TO lt_documents.
      ENDLOOP.
      IF NOT lt_documents IS INITIAL.
        CALL FUNCTION 'MMPUR_LIST_SERNOS'
          EXPORTING
            im_documents = lt_documents.
      ENDIF.
      CALL METHOD select_items
        EXPORTING
          im_deselect = t_yes.
    ELSE.
      MESSAGE s103(06).
    ENDIF.
  ENDMETHOD.                    "serial_list

*----------------------------------------------------------------------*
  METHOD execute_before_transport.

    DATA: ls_item LIKE LINE OF selection,
          lt_selection LIKE selection,
          ls_data LIKE LINE OF item_data_pai,
          l_loekz LIKE ls_data-data-loekz.
    DATA: l_item         TYPE REF TO if_purchase_requisition_item,
          l_header       TYPE REF TO if_purchase_requisition,
          l_item_data    TYPE mereq_item,
          l_tabix        TYPE sy-tabix,
          l_answer       TYPE c.

    IF im_fcode = 'MEREQ3211LNKDOCS'.                       "526768

      CALL METHOD linked_dms_documents.

    ELSEIF im_fcode = 'MEREQ3211ITEMCOPY'.

      CALL METHOD copy_items.

*DCM complete all selected versions
    ELSEIF im_fcode = 'MEREQDCMALL'.
      CALL METHOD complete_version_all.

    ELSEIF im_fcode = 'MEREQMASS'.

      DATA: l_gt TYPE REF TO lcl_mass_change,
        lt_cols TYPE lvc_t_col,
        ls_col  LIKE LINE OF lt_cols,
        l_view  TYPE REF TO cl_screen_view_mm,
        l_table_control TYPE REF TO cl_table_view_mm,
        lt_models TYPE mmpur_models,
        lt_all_models TYPE mmpur_models.

      CALL METHOD get_selection
        IMPORTING
          ex_models = lt_models.

      CALL METHOD get_items
        IMPORTING
          ex_models = lt_all_models.

      CALL METHOD get_selected_columns
        IMPORTING
          ex_row_col_table = lt_cols.

      CREATE OBJECT l_gt.

      CALL METHOD l_gt->start
        EXPORTING
          im_structname    = 'MEREQ_ITEM'
          im_selected_cols = lt_cols
          im_selected_objs = lt_models
          im_all_objs      = lt_all_models.

    ELSEIF im_fcode = 'MEREQCATALOG'.
      CALL METHOD get_catalog.

    ELSEIF im_fcode = 'MEREQEXTMATSEARCH'.

      CALL METHOD call_ext_mat_search.

    ENDIF.

  ENDMETHOD.                    "execute_before_transport
*----------------------------------------------------------------------*
  METHOD get_catalog.

    DATA: lt_cat_item      TYPE item_catalog_table_type,
          ls_cat_item      TYPE item_catalog_data_type,
          ls_data          LIKE LINE OF item_data_pai,
          lines            TYPE i,
          l_item_data      TYPE mereq_item,
          lt_models        TYPE mmpur_models,
          l_model          TYPE LINE OF mmpur_models,
          ls_item_data_pai TYPE item_data_type.

*- find 'existend' and selected items --------------------------------*
    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

*- generate input file over all 'exist' items ... --------------------*
    LOOP AT lt_models INTO l_model.
      ls_cat_item-model ?= l_model-model.
*     ... from object
      l_item_data = ls_cat_item-model->get_data( ).
      MOVE-CORRESPONDING l_item_data TO ls_cat_item-data.
      MOVE-CORRESPONDING l_item_data TO ls_cat_item-material.
      MOVE-CORRESPONDING l_item_data TO ls_cat_item-valuation.
      MOVE-CORRESPONDING l_item_data TO ls_cat_item-quantity.
      MOVE-CORRESPONDING l_item_data TO ls_cat_item-source.
*     ... and from item overview dynpro
      READ TABLE item_data_pai WITH KEY model = ls_cat_item-model
                               INTO ls_item_data_pai.
      MOVE-CORRESPONDING ls_item_data_pai-data TO ls_cat_item-data.
      APPEND ls_cat_item TO lt_cat_item.
      CLEAR ls_cat_item.
    ENDLOOP.

*- append a proposed item for new items from catalog -----------------*
    IF NOT my_item_proposer IS INITIAL AND
       my_model_changeable EQ mmpur_yes.
      CALL METHOD conversions_output
        EXPORTING
          im_item = my_proposed_item
        IMPORTING
          ex_data = ls_data.
      ls_cat_item-data = ls_data-data.
      APPEND ls_cat_item TO lt_cat_item.
      CLEAR ls_cat_item.
    ENDIF.

*- get data from catalog ---------------------------------------------*
    CALL METHOD read_from_catalog
      CHANGING
        im_item_table  = lt_cat_item
      EXCEPTIONS
        map_error      = 1
        illegal_call   = 2
        no_data_import = 3.

*- set catalog items to model ----------------------------------------*
    IF sy-subrc LE 1.
      DESCRIBE TABLE lt_cat_item LINES lines.
    ENDIF.
    CHECK NOT lines IS INITIAL.
    LOOP AT lt_cat_item INTO ls_cat_item.
      CALL METHOD transport_from_catalog
        CHANGING
          im_item  = ls_cat_item
          im_model = ls_cat_item-model.
    ENDLOOP.

  ENDMETHOD.                    "get_catalog

  METHOD call_ext_mat_search.

    DATA: ls_search_param TYPE wsd_ms_initial_params_sty,
          lt_matlist      TYPE wsd_ms_return_tty,
          ls_material_data  TYPE wsd_ms_return_sty,
          ls_header_data  TYPE mereq_header,
          ls_item_data    TYPE mereq_item,
          ls_item_datax   TYPE mereq_itemx,
          ls_proposer_data TYPE item_data_type,
          ls_werks        TYPE werks_d,
          lref_header     TYPE REF TO if_purchase_requisition,
          l_item          TYPE REF TO if_purchase_requisition_item,
          ls_basic_cfg    TYPE wsdt_basic_cfg.

    mmpur_dynamic_cast lref_header my_model.

    CHECK NOT lref_header IS INITIAL.

    IF lref_header->is_valid( ) IS INITIAL.
      EXIT.
    ENDIF.

    ls_header_data = lref_header->get_data( ).

    ls_basic_cfg = cl_wsd_config=>read_mat_basic_config( i_app_name = cl_wsd_constants=>co_appl_purchase_order ).

    IF ls_basic_cfg-so_active IS INITIAL.
      RETURN.
    ENDIF.

    IF NOT my_item_proposer IS INITIAL AND
       my_model_changeable EQ mmpur_yes.
      CALL METHOD conversions_output
        EXPORTING
          im_item = my_proposed_item
        IMPORTING
          ex_data = ls_proposer_data.

    ENDIF.
* determine plant from personal settings or user paraneter
    IF ls_proposer_data-data-werks IS INITIAL.
      CALL FUNCTION 'WSD_READ_PLANT_PARAM'
        IMPORTING
          e_werks = ls_werks.
      IF ls_werks IS INITIAL.
        CALL FUNCTION 'WSD_SELECT_OWN_PLANT'
          IMPORTING
            e_werks = ls_werks.
      ENDIF.
    ELSE.
      ls_werks = ls_proposer_data-data-werks.
    ENDIF.

    IF ls_werks IS NOT INITIAL.
      ls_search_param-app_name = cl_wsd_constants=>co_appl_purchase_order.
      ls_search_param-werks = ls_werks.

      CALL FUNCTION 'WSD_MATERIAL_SEARCH' DESTINATION 'NONE'
        EXPORTING
          is_params             = ls_search_param
        IMPORTING
          et_return             = lt_matlist
        EXCEPTIONS
          communication_failure = 1
          system_failure        = 2.

      LOOP AT lt_matlist INTO ls_material_data.

        CALL METHOD conversions_output
          EXPORTING
            im_item = my_proposed_item
          IMPORTING
            ex_data = ls_proposer_data.
        MOVE-CORRESPONDING ls_proposer_data-data TO ls_item_data.
        ls_item_data-matnr = ls_material_data-matnr.
        ls_item_datax-matnr = 'X'.
        ls_item_data-werks = ls_material_data-werks.
        ls_item_datax-werks = 'X'.
        ls_item_data-menge = ls_material_data-kwmeng.
        ls_item_datax-menge = 'X'.
        ls_item_data-meins = ls_material_data-vrkme.
        ls_item_datax-meins = 'X'.
        l_item = lref_header->create_item( ).
        IF l_item IS BOUND.
          CALL METHOD l_item->set_data( ls_item_data ).
          CALL METHOD l_item->set_datax( ls_item_datax ).
          CALL METHOD notify_data_changed( l_item ).
        ENDIF.
      ENDLOOP.
      CALL FUNCTION 'MARC_ARRAY_READ'
        EXPORTING
          kzrfb  = 'X'
        EXCEPTIONS
          OTHERS = 1.
      IF sy-subrc <> 0.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "call_ext_mat_search

*----------------------------------------------------------------------*
  METHOD get_proposer_data.

    DATA: l_ref         TYPE REF TO data,
          l_req         TYPE REF TO if_purchase_requisition,
          l_header      TYPE mereq_header.

    FIELD-SYMBOLS: <data> TYPE mereq_prop.

    CHECK my_model_changeable EQ mmpur_yes.

    IF NOT my_item_proposer IS INITIAL.

      CALL METHOD my_item_proposer->if_dataprovider_mm~get_data
        IMPORTING
          ex_data = l_ref.

      ASSIGN l_ref->* TO <data>.
* transport information into my_proposed_item
      CLEAR my_proposed_item.
      MOVE-CORRESPONDING <data> TO my_proposed_item.
      CALL FUNCTION 'PERIOD_AND_DATE_CONVERT_INPUT'
        EXPORTING
          external_date              = <data>-eeind
          external_period            = <data>-elpei
          dialog_date_is_in_the_past = space
        IMPORTING
          internal_date              = my_proposed_item-lfdat
          internal_period            = my_proposed_item-lpein
        EXCEPTIONS
          error_message              = 1
          OTHERS                     = 2.
      IF NOT sy-subrc IS INITIAL.
        CLEAR: my_proposed_item-lfdat, my_proposed_item-lpein.
        DATA: l_tprg            TYPE tprg.
        IF NOT <data>-elpei IS INITIAL.
          SELECT SINGLE * FROM tprg INTO l_tprg WHERE
                             spras = sy-langu AND
                             prgbz = <data>-elpei.
          IF sy-subrc IS INITIAL.
            my_proposed_item-lpein = l_tprg-prgrs.
          ENDIF.
        ENDIF.
      ENDIF.

* get a value for the document type on item level
      mmpur_dynamic_cast l_req my_model.
      IF NOT l_req IS INITIAL.
        l_header = l_req->get_data( ).
        my_proposed_item-bsart = l_header-bsart.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "get_proposer_data

*----------------------------------------------------------------------*
  METHOD conversions_output.

    DATA: l_item_data_entry TYPE item_data_type.

    CLEAR l_item_data_entry.
    MOVE-CORRESPONDING im_item TO l_item_data_entry-data.

* non-generic conversions

* item category
    CALL METHOD my_converter->convert_pstyp_output
      EXPORTING
        im_pstyp = im_item-pstyp
      IMPORTING
        ex_epstp = l_item_data_entry-data-epstp.
* plant
    CALL METHOD my_converter->convert_plant_output
      EXPORTING
        im_werks = im_item-werks
      IMPORTING
        ex_name1 = l_item_data_entry-data-name1.
* deliv.
    CALL METHOD my_converter->convert_plant_output
      EXPORTING
        im_werks = im_item-reswk
      IMPORTING
        ex_name1 = l_item_data_entry-data-resbz.

* material group
    CALL METHOD my_converter->convert_matkl_output
      EXPORTING
        im_matkl = im_item-matkl
      IMPORTING
        ex_wgbez = l_item_data_entry-data-wgbez.
* storage location
    CALL METHOD my_converter->convert_lgort_output
      EXPORTING
        im_werks = im_item-werks
        im_lgort = im_item-lgort
      IMPORTING
        ex_lgobe = l_item_data_entry-data-lgobe.
* Conversion of Supplying Sloc and Reswk
* supplying sloc
    CALL METHOD my_converter->convert_lgort_output
      EXPORTING
        im_werks = im_item-reswk
        im_lgort = im_item-reslo
      IMPORTING
        ex_lgobe = l_item_data_entry-data-reslo_bez.

* del. date
    CALL METHOD my_converter->convert_eindt_output
      EXPORTING
        im_lpein = im_item-lpein
        im_eindt = im_item-lfdat
      IMPORTING
        ex_elpei = l_item_data_entry-data-elpei
        ex_eeind = l_item_data_entry-data-eeind.

* end of non-generic conversions
    ex_data = l_item_data_entry.

  ENDMETHOD.                    "conversions_output

*----------------------------------------------------------------------*

  METHOD on_event_double_click.

    DATA: l_item   TYPE REF TO if_purchase_requisition_item.
    DATA: l_parent TYPE REF TO cl_screen_view_mm.
    DATA: l_name   TYPE string40.

    CHECK ex_view EQ me.
    CHECK NOT ex_model IS INITIAL.

    mmpur_dynamic_cast l_item ex_model.
    CHECK NOT l_item IS INITIAL.

    CASE ex_metafield.
      WHEN mmmfd_acctasscat.
        l_name = c_accountings.
      WHEN mmmfd_textflag.
        l_name = c_item_texts.
    ENDCASE.

    IF NOT l_name IS INITIAL.

      l_parent = me->parent_view.

      DO.
        IF l_parent->parent_view IS INITIAL.
          EXIT.
        ENDIF.

        l_parent = l_parent->parent_view.

      ENDDO.

      CALL METHOD l_parent->lookup
        EXPORTING
          im_name   = l_name
        IMPORTING
          ex_view   = l_parent
        EXCEPTIONS
          not_found = 1.

      IF sy-subrc EQ 0 AND NOT l_parent IS INITIAL.
        CALL METHOD l_parent->set_focus.
        CALL METHOD if_multiple_model_holder_mm~set_current_model(
          l_item ).
      ENDIF.

    ELSEIF ex_metafield EQ mmmfd_preq_item.

      CALL METHOD if_multiple_model_holder_mm~set_current_model(
        l_item ).
    ELSEIF ex_metafield EQ mmmfd_banpricon.
      CALL METHOD process_banpr( l_item ).

    ENDIF.


  ENDMETHOD.                    "on_event_double_click

*----------------------------------------------------------------------*

  METHOD assign_source_of_supply.

    DATA: lt_models        TYPE mmpur_models,
          ls_models        LIKE LINE OF lt_models,
          l_req            TYPE REF TO if_purchase_requisition_item,
          l_source_manager TYPE REF TO cl_source_manager_mm.

    CHECK my_model_changeable EQ mmpur_yes.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    l_source_manager = cl_source_manager_mm=>get_instance( ).

    LOOP AT lt_models INTO ls_models.

      mmpur_dynamic_cast l_req ls_models-model.

      CHECK NOT l_req IS INITIAL.

      CALL METHOD l_source_manager->search( im_bo = l_req ).

    ENDLOOP.
* sync gui framework
    CALL METHOD if_multiple_model_holder_mm~set_current_model(
      my_current_model ).

  ENDMETHOD.                    "assign_source_of_supply

*---------------------------------------------------------------------*

  METHOD availability_check.

    DATA: lt_models      TYPE mmpur_models,
          ls_models      LIKE LINE OF lt_models,
          l_req_item     TYPE REF TO if_purchase_requisition_item.

    CHECK my_model_changeable EQ mmpur_yes.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      mmpur_dynamic_cast l_req_item ls_models-model.

      CHECK NOT l_req_item IS INITIAL.

      CALL METHOD l_req_item->availability_check
        EXPORTING
          im_mode = if_purchase_requisition_item=>c_acmod_explicit.

    ENDLOOP.

  ENDMETHOD.                    "availability_check

*---------------------------------------------------------------------*

  METHOD linked_dms_documents.
    DATA: lt_models      TYPE mmpur_models,
          ls_models      LIKE LINE OF lt_models,
          l_dms_cnt      TYPE REF TO if_command_mm,
          l_fcode        TYPE sy-ucomm VALUE 'DUMMY'.

    CREATE OBJECT l_dms_cnt
      TYPE
      lcl_dms_controller.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      CALL METHOD l_dms_cnt->execute
        EXPORTING
          im_model = ls_models-model
        CHANGING
          im_fcode = l_fcode.

*DCM trigger new version
      CALL METHOD notify_data_changed( ls_models-model ).

      IF l_fcode IS INITIAL.
        EXIT.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "linked_dms_documents

*---------------------------------------------------------------------*

  METHOD execute.
    CALL METHOD super->execute
      CHANGING
        im_fcode = im_fcode.

    CASE im_fcode.
      WHEN 'MEREQ3211DELETE' OR 'MEREQ3211UNLOCK'.          "526768
        CALL METHOD req_delete
          EXPORTING
            im_fcode = im_fcode.                            "526768
      WHEN 'MEITSOURCEASSIGN'.
        CALL METHOD assign_source_of_supply.
        CLEAR im_fcode.
      WHEN 'MEREQAVAIL'.
        CALL METHOD availability_check.
        CLEAR im_fcode.
      WHEN 'MEREQCATALOG'.
        CALL METHOD catalog_texts.
        CLEAR im_fcode.
      WHEN 'SN_OVERVIEW'.
        CALL METHOD serial_list.
        CLEAR im_fcode.
    ENDCASE.
  ENDMETHOD.                    "execute

*---------------------------------------------------------------------*

* Begin of note 526768
  METHOD req_delete.
    DATA: ls_selection LIKE LINE OF selection,
          lt_selection LIKE selection,
          l_item       TYPE REF TO if_purchase_requisition_item,
          fw           TYPE REF TO cl_framework_mm,
          ls_mereqitem TYPE mereq_item,
          l_loekz      TYPE mereq_item-loekz,
          l_answer     TYPE c.

    CASE im_fcode.
      WHEN 'MEREQ3211DELETE'.
        l_loekz = 'X'.
      WHEN 'MEREQ3211UNLOCK'.
        l_loekz = space.
    ENDCASE.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_selection.

    IF NOT lt_selection[] IS INITIAL.

      IF im_fcode = 'MEREQ3211DELETE'.
        CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
          EXPORTING
            defaultoption = 'N'
            diagnosetext1 = text-312
            diagnosetext2 = text-313
            diagnosetext3 = text-314
            textline1     = text-316
            titel         = text-315
          IMPORTING
            answer        = l_answer.
      ENDIF.

      IF im_fcode NE 'MEREQ3211DELETE' OR l_answer = 'J'.
        LOOP AT lt_selection INTO ls_selection.

          mmpur_dynamic_cast l_item ls_selection-model.

          CHECK NOT l_item IS INITIAL.

          CALL METHOD l_item->get_data
            RECEIVING
              re_data = ls_mereqitem.
          ls_mereqitem-loekz = l_loekz.
          CALL METHOD l_item->set_data
            EXPORTING
              im_data = ls_mereqitem.
        ENDLOOP.
        IF sy-subrc IS INITIAL.
*  update business object
          CALL METHOD cl_framework_mm=>get_instance
            IMPORTING
              ex_instance = fw.
          CALL METHOD fw->process_models
            EXPORTING
              im_models = lt_selection
            EXCEPTIONS
              failed    = 1.
        ENDIF.
      ENDIF.                         "user confirms function
      CALL METHOD select_items
        EXPORTING
          im_deselect = t_yes.
    ENDIF.                           "table is not initial

  ENDMETHOD.                    "req_delete
* End of note 526768

*---------------------------------------------------------------------*

  METHOD copy_items.

    DATA: lt_models TYPE mmpur_models,
          ls_models LIKE LINE OF lt_models,
          l_item    TYPE REF TO if_purchase_requisition_item,
          l_req     TYPE REF TO if_purchase_requisition.

    mmpur_dynamic_cast l_req my_model.
    CHECK NOT l_req IS INITIAL.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    LOOP AT lt_models INTO ls_models.
      mmpur_dynamic_cast l_item ls_models-model.

      CHECK NOT l_item IS INITIAL.

      l_item = l_req->create_item( im_item = l_item ).
      IF NOT l_item IS INITIAL.
        CALL METHOD notify_data_changed( l_item ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "copy_items

*---------------------------------------------------------------------*

  METHOD copy_with_reference.

    DATA: lt_req_items        TYPE mmpur_requisition_items,
          lt_docs             TYPE mepo_documents,
          l_mepo_doc          TYPE mepo_document,
          l_option            TYPE mepo_initiator_option,
          l_req               TYPE REF TO if_purchase_requisition.

    CHECK NOT im_banfn IS INITIAL.

    mmpur_dynamic_cast l_req my_model.
    CHECK NOT l_req IS INITIAL.

    l_mepo_doc-doc_key = im_banfn.
    l_mepo_doc-process = mmpur_req_process.
    l_mepo_doc-trtyp = anz.
    l_mepo_doc-doc_type = bstyp-banf.

    IF NOT im_bnfpo IS INITIAL.
      l_option-property = mmpur_requested_item.
      l_option-value    = im_bnfpo.
      INSERT l_option INTO TABLE l_mepo_doc-initiator-options.
    ENDIF.

    INSERT l_mepo_doc INTO TABLE lt_docs.

    lt_req_items = l_req->create_items_by_key( lt_docs ).
    APPEND LINES OF lt_req_items TO re_items.

  ENDMETHOD.                    "copy_with_reference

*DCM
  METHOD process_banpr.

    DATA: l_item        TYPE mereq_item,
          l_releasable  TYPE REF TO if_releasable_mm,
          l_buyer       TYPE REF TO if_buyers_approval_mm,
          l_dcm_adapter TYPE REF TO if_dcm_adapter,
          l_dcm         TYPE REF TO if_revision_manager_dcm,
          lt_models     TYPE mmpur_models,
          ls_model      LIKE LINE OF lt_models,
          l_flush       TYPE REF TO if_flush_transport_mm.

    CHECK NOT im_req_item IS INITIAL.
    l_item = im_req_item->get_data( ).
    CASE l_item-banpr.

      WHEN cl_process_state_mm=>c_rejected.
        mmpur_dynamic_cast l_releasable im_req_item.
        IF NOT l_releasable IS INITIAL.
          IF l_releasable->is_reset_rej_allowed( ) EQ mmpur_yes.
            CALL METHOD l_releasable->reject
              EXPORTING
                im_reset = mmpur_yes
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s818(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_buyer_rejected.
        mmpur_dynamic_cast l_buyer im_req_item.
        IF NOT l_buyer IS INITIAL.
          IF l_buyer->is_reset_rej_allowed( ) EQ mmpur_yes.
            CALL METHOD l_buyer->reject
              EXPORTING
                im_reset = mmpur_yes
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s803(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_final_approval.
        mmpur_dynamic_cast l_buyer im_req_item.
        IF NOT l_buyer IS INITIAL.
          IF l_buyer->is_acceptance_allowed( ) EQ mmpur_yes.
            CALL METHOD l_buyer->accept
              EXPORTING
                im_reset = mmpur_no
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s809(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_release_active.
        mmpur_dynamic_cast l_releasable im_req_item.
        IF NOT l_releasable IS INITIAL.
          IF l_releasable->is_release_allowed( ) EQ mmpur_yes.
            CALL METHOD l_releasable->initiate_release
              EXPORTING
                im_reset = mmpur_no
                im_all   = mmpur_yes
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s804(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_revision_active.
        mmpur_dynamic_cast l_dcm_adapter im_req_item.
        IF NOT l_dcm_adapter IS INITIAL
        AND l_dcm_adapter->is_complete_version_allowed( ) EQ mmpur_yes..
          l_dcm = l_dcm_adapter->get_manager( ).
          IF NOT l_dcm IS INITIAL.
            CALL METHOD l_dcm->complete_item( ).
            CALL METHOD notify_data_changed( im_req_item ).
            l_flush ?=
               im_req_item->if_flush_transport_mm~can_initiate_flush( ).
            ls_model-model = im_req_item.
            APPEND ls_model TO lt_models.
            CALL METHOD l_flush->start
              EXPORTING
                im_models = lt_models
              EXCEPTIONS
                OTHERS    = 0.
          ENDIF.
        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "process_banpr

*.. complete versions in all selected items
  METHOD complete_version_all.

    DATA: lt_models      TYPE mmpur_models,
          ls_models      LIKE LINE OF lt_models,
          l_fcode        TYPE sy-ucomm VALUE 'DUMMY',
          ls_mereqitem   TYPE mereq_item,
          l_req          TYPE REF TO if_purchase_requisition_item.

    CHECK my_model_changeable EQ mmpur_yes.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      mmpur_dynamic_cast l_req ls_models-model.
      CHECK NOT l_req IS INITIAL.

      ls_mereqitem = l_req->get_data( ).
      IF ls_mereqitem-banpr EQ cl_process_state_mm=>c_revision_active.
        CALL METHOD process_banpr( l_req ).
      ENDIF.

      CALL METHOD notify_data_changed( ls_models-model ).

      IF l_fcode IS INITIAL.
        EXIT.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "complete_version_all

ENDCLASS.                    "lcl_req_item_table IMPLEMENTATION


*---------------------------------------------------------------------*
*       CLASS lcl_req_item_grid IMPLEMENTATION
*---------------------------------------------------------------------*
CLASS lcl_req_item_grid   IMPLEMENTATION.

  METHOD constructor.

    CALL METHOD super->constructor
      EXPORTING
        im_dynpro         = im_dynpro
        im_prog           = im_prog
        im_container_ref  = im_container_ref
        im_container_name = im_container_name
        im_struct_name    = im_struct_name.

    my_converter = lcl_converter=>get_instance( ).

    DATA: fw           TYPE REF TO cl_framework_mm,
          l_objecttype TYPE string40.

    CALL METHOD cl_framework_mm=>get_instance
      IMPORTING
        ex_instance = fw.
    l_objecttype = if_purchase_requisition=>c_objtyp.
    my_proposer ?= fw->get_proposer( l_objecttype ).

    DATA: null TYPE REF TO if_command_mm.

    CREATE OBJECT my_dragdrop_controller
      EXPORTING
        im_model    = my_model   "null !!
        im_commands = null.

    SET HANDLER handle_data_dropped FOR my_dragdrop_controller.
    SET HANDLER on_event_double_click FOR me.

    my_disvariant-handle = im_handle.

    DATA: l_info TYPE icont-quickinfo.
    l_info = text-905.
    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name   = icon_led_red
        info   = l_info
      IMPORTING
        result = my_icon_led_red
      EXCEPTIONS
        OTHERS = 0.

    l_info = text-906.
    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name   = icon_led_yellow
        info   = l_info
      IMPORTING
        result = my_icon_led_yellow
      EXCEPTIONS
        OTHERS = 0.

  ENDMETHOD.                    "constructor

  METHOD build_dynpro_fields.

    DATA: ls_fcat LIKE LINE OF gt_fieldcatalog,
          lf_reslo_allowed TYPE c.   " SSLOC
    DATA: l_badi_grid TYPE REF TO megui_grid_enhancement.

    my_model_cell = 'OBJREF'.

    CALL METHOD super->build_dynpro_fields( ).

*   BAdI 'MEGUI_GRID_ENHANCEMENT' to map new dynprofields
    TRY.
        GET BADI l_badi_grid.

        CALL BADI l_badi_grid->build_dynpro_fields_req
          CHANGING
            ch_mapping = my_dynpro_fields.

      CATCH cx_badi_not_implemented .
    ENDTRY.
*  ***

    CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
      EXPORTING
        i_buffer_active        = 'X'
        i_structure_name       = 'MEREQ3211GRID'
      CHANGING
        ct_fieldcat            = gt_fieldcatalog
      EXCEPTIONS
        inconsistent_interface = 1
        program_error          = 2
        OTHERS                 = 3.
    IF sy-subrc <> 0.
    ENDIF.

    IF  cl_ops_switch_check=>mm_sfws_p2pse( ) IS INITIAL.
** Delete new fields for Central Contract from fieldcatalog
** if switch is not active
      DELETE gt_fieldcatalog WHERE fieldname EQ 'SRM_CONTRACT_ID' OR
                                   fieldname EQ 'SRM_CONTRACT_ITM'.
    ENDIF.

* Delete Budget Period if the switch is inactive
    IF cl_ops_switch_check=>ops_sfws_bud_per( ) IS INITIAL.
      DELETE gt_fieldcatalog WHERE fieldname = 'BUDGET_PD'.
    ENDIF.

* Check if the supplying storage location is allowed
    CALL FUNCTION 'ME_DELIV_STRG_LOC_ACTIVE'    " SSLOC
      IMPORTING
        ef_del_strg_loc_act = lf_reslo_allowed.


    LOOP AT gt_fieldcatalog INTO ls_fcat.
      ls_fcat-no_init_ch = 'B'.
      CASE ls_fcat-fieldname.

* technical fields
        WHEN 'BSTYP' OR
             'BSAKZ' OR
             'LOEKZ' OR
             'FRGZU' OR
             'VRTYP' OR
             'PSTYP' OR
             'ZUGBA' OR
             'QUNUM' OR
             'QUPOS' OR
             'SERNR' OR
             'BVDAT' OR                " Wiedervorlage nicht mehr
             'BATOL' OR
             'BVDRK' OR
             'XOBLR' OR
             'VORAB' OR
             'PACKNO' OR
             'KANBA' OR
             'CUOBJ' OR
             'FRGRL' OR
             'UMSOK' OR
             'VERID' OR
             'ADRNR' OR
             'ADRN2' OR
             'GSFRG' OR
             'KZFME' OR
             'TECHS' OR
             'BERID' OR
             'LPEIN' OR
             'LFDAT' OR
             'ALV_DATA_CHANGED' OR
             'BANFN' OR
             'SOURCE_ASSIGNED' OR
             'EDIT' OR
             'RFQ_REQUISTED' OR
             'MEREQITEMDUMMY'.

          ls_fcat-tech = 'X'.

*icons
        WHEN 'STATUSICON' OR
             'BANPRICON'.

          ls_fcat-icon = 'X'.
          ls_fcat-hotspot = 'X'.
          ls_fcat-outputlen = 2.
          ls_fcat-fix_column = 'X'.

* check boxes editable
        WHEN 'WEPOS' OR
             'REPOS' OR
             'FIXKZ' OR
             'WEUNB'.

          ls_fcat-edit = 'X'.
          ls_fcat-checkbox = 'X'.
          ls_fcat-f4availabl = 'C'.

* Textflag icon
        WHEN 'TEXTFLAG'.
          ls_fcat-icon = 'X'.
          ls_fcat-hotspot = 'X'.
          ls_fcat-outputlen = 2.

* fields which never can be changed.
        WHEN 'STATU' OR
             'BSART' OR                                     "633850
             'ESTKZ' OR
             'FRGKZ' OR
             'FRGST' OR
             'ERNAM' OR
             'ERDAT' OR
             'BUMNG' OR
             'VRTKZ' OR
             'TWRKZ' OR
             'EBELN' OR
             'EBELP' OR
             'BEDAT' OR
             'BSMNG' OR
             'LBLNI' OR
             'RSNUM' OR
             'ARSNR' OR
             'ARSPS' OR
             'FRGGR' OR
             'KZKFG' OR
             'SATNR' OR
             'MNG02' OR
             'DAT01' OR
             'ATTYP' OR
             'KUNNR' OR
             'KZBWS' OR
             'SOBKZ' OR
             'SPRAS' OR
             'FORDN' OR
             'FORDP' OR
             'MFRPN' OR
             'MFRNR' OR
             'EMNFR' OR
             'MPROF' OR
             'FIPOS' OR                                     "956564
             'FISTL' OR
             'GEBER' OR
             'EMLIF' OR                                     "994567
             'LBLKZ'.                                       "994567

          ls_fcat-edit = ' '.

        WHEN 'KZVBR' OR
             'BPUEB'.                                       "515847
*         this suppresses foreign key check in the alv grid control
*         for certain technical fields
*         (see CL_GUI_ALV_GRID=>GET_OTHER_CHECKFIELDS)
          ls_fcat-tech = 'X'.
          ls_fcat-checktable = '!'.

        WHEN 'RESLO'.
          IF lf_reslo_allowed NE 'X'.
            ls_fcat-tech = 'X'.
          ELSE.
            ls_fcat-edit = 'X'.
          ENDIF.

        WHEN 'IUID_RELEVANT'.                               "EHP603
*         must be unswitched!
          IF cl_uid_cust=>get_uid_used( cl_uid_cust=>gc_iuid ) IS INITIAL.
            ls_fcat-tech = 'X'.
          ELSE.
            ls_fcat-edit = 'X'.
            ls_fcat-checkbox = 'X'.
            ls_fcat-f4availabl = 'C'.
          ENDIF.

* fields for shelf life need to be switched        "Shelf Life ECC 7.0
        WHEN 'MHDRZ' OR
             'IPRKZ'.
          ls_fcat-tech = 'X'.
          ENHANCEMENT-POINT EHP603_LMEGUICJM_01 SPOTS ES_SAPLMEGUI_SHLF .
*$*$-Start: EHP603_LMEGUICJM_01-----------------------------------------------------------------$*$*
ENHANCEMENT 1  ME_LMEGUICJM_01.    "active version
          CLEAR ls_fcat-tech.
          ls_fcat-edit = 'X'.
ENDENHANCEMENT.
*$*$-End:   EHP603_LMEGUICJM_01-----------------------------------------------------------------$*$*

        WHEN OTHERS.

          ls_fcat-edit = 'X'.

      ENDCASE.

      MODIFY gt_fieldcatalog FROM ls_fcat.
    ENDLOOP.

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""$"$\SE:(1) Class LCL_REQ_ITEM_GRID, Method BUILD_DYNPRO_FIELDS, End                                                                                          A
*$*$-Start: (1)---------------------------------------------------------------------------------$*$*
ENHANCEMENT 1  ZAPIMPMM0001.    "active version
** Display Search Help AFNAM / BEDNR in Item PR
  LOOP AT gt_fieldcatalog INTO ls_fcat WHERE fieldname EQ 'AFNAM'.
    MOVE 'MEREQ3328' TO ls_fcat-REF_TABLE.
    MODIFY gt_fieldcatalog FROM ls_fcat.
  ENDLOOP.
  LOOP AT gt_fieldcatalog INTO ls_fcat WHERE fieldname EQ 'BEDNR'.
    MOVE 'MEREQ3328' TO ls_fcat-REF_TABLE.
    MODIFY gt_fieldcatalog FROM ls_fcat.
  ENDLOOP.

ENDENHANCEMENT.
*$*$-End:   (1)---------------------------------------------------------------------------------$*$*
  ENDMETHOD.                    "build_dynpro_fields

  METHOD fs_get.

    DATA: l_model          TYPE REF TO if_model_mm,
          l_requested_type TYPE string40,
          l_badi_grid      TYPE REF TO megui_grid_enhancement.

    IF NOT im_model IS INITIAL.
      l_model = im_model.
      l_requested_type = im_requested_type.
    ELSE.
      l_model = my_model.
      l_requested_type = if_purchase_requisition=>c_objtyp.
    ENDIF.
    CALL METHOD super->fs_get(
        im_model          = l_model
        im_requested_type = l_requested_type ).

*   BAdI 'MEGUI_GRID_ENHANCEMENT'
    TRY.
        GET BADI l_badi_grid.

        CALL BADI l_badi_grid->fs_get_req
          CHANGING
            ch_fieldselection = my_fieldselection.

      CATCH cx_badi_not_implemented .
    ENDTRY.

  ENDMETHOD.                    "fs_get

  METHOD set_model.

    DATA: l_aktyp TYPE aktyp.
    my_release_filter_on = mmpur_no.

    mmpur_dynamic_cast my_req im_model.

    IF NOT my_req IS INITIAL.

      l_aktyp = my_req->get_activity( ).

      IF l_aktyp EQ hin OR l_aktyp EQ ver.
        my_changeable = mmpur_yes.
      ELSE.
        my_changeable = mmpur_no.
      ENDIF.

      CALL METHOD transport_from_model( im_model ).

      GET REFERENCE OF my_table INTO gt_table.
      my_dirty_flag = mmpur_yes.

    ENDIF.

    CALL METHOD super->set_model( im_model ).

  ENDMETHOD.                    "set_model

  METHOD transport_from_model.
    DATA: ls_data LIKE LINE OF my_table,
          l_mereqi TYPE mereq_item,
          lt_items TYPE mmpur_requisition_items,
          ls_item  LIKE LINE OF lt_items,
          l_req_item TYPE REF TO if_purchase_requisition_item,
          l_new_current LIKE my_current_model,
          lv_archived    TYPE mmpur_bool.                   "967951

    l_new_current = my_current_model.

    IF im_model EQ my_req.

      CALL METHOD get_proposer_data( ).

      lt_items = my_req->get_items( im_auth_check = mmpur_yes
                                    im_release_op = my_release_filter_on ).

      IF NOT l_new_current IS INITIAL.
        mmpur_dynamic_cast l_req_item l_new_current.

        IF NOT l_req_item IS INITIAL.

          READ TABLE lt_items INTO ls_item
            WITH KEY item = l_req_item.

          IF NOT sy-subrc IS INITIAL.
            CLEAR l_new_current.

            READ TABLE my_table INTO ls_data
              WITH KEY objref = l_req_item.

            IF sy-subrc IS INITIAL.

              LOOP AT my_table INTO ls_data FROM sy-tabix.

                READ TABLE lt_items INTO ls_item
                    WITH KEY item = ls_data-objref.

                IF sy-subrc IS INITIAL.
                  l_new_current = ls_data-objref.

                  EXIT.
                ENDIF.

              ENDLOOP.
            ENDIF.

          ENDIF.
        ELSE.
          CLEAR l_new_current.
        ENDIF.
      ENDIF.

      IF l_new_current IS INITIAL AND
         NOT lt_items[] IS INITIAL.
        READ TABLE lt_items INTO ls_item INDEX 1.
        l_new_current = ls_item-item.
      ENDIF.

      REFRESH my_table.
      lv_archived = me->my_req->is_archived( ).             "967951

      LOOP AT lt_items INTO ls_item.
        l_req_item = ls_item-item.

        l_mereqi = l_req_item->get_data( ).
* set archived indicator for switching the displayed icon
        IF lv_archived EQ cl_mmpur_constants=>yes.          "967951
          l_mereqi-loekz = cl_mmpur_constants=>archived.
        ENDIF.

        CALL METHOD conversions_output
          EXPORTING
            im_item = l_mereqi
            im_obj  = l_req_item
          IMPORTING
            ex_data = ls_data.
        ls_data-objref = l_req_item.
        ls_data-alv_data_changed = mmpur_no.
*        move-corresponding l_mereqi to ls_data.
        APPEND ls_data TO my_table.
      ENDLOOP.
* government procurement: fill ALV Griid with SRM purchasing group
*spiin activ.
      DATA: lv_active TYPE boolean.
      DATA: ls_header_data TYPE mereq_header.
      lv_active = /sappspro/cl_numbers=>is_active( ).       "1103935

      IF lv_active = 'X'.
        ls_header_data = my_req->get_data( ).
        MOVE-CORRESPONDING ls_header_data TO ls_data.
        MODIFY my_table FROM ls_data TRANSPORTING banfn
                             WHERE banfn IS INITIAL.
        CALL FUNCTION '/SAPPSPRO/DETERM_SRM_PURGRP '
          CHANGING
            ct_table = my_table.
      ENDIF.
*
* propose blank lines
*
      IF my_changeable EQ mmpur_yes.
        CLEAR: ls_data, l_req_item.

        DO 10 TIMES.
          CALL METHOD conversions_output
            EXPORTING
              im_item = my_proposed_item
              im_obj  = l_req_item
            IMPORTING
              ex_data = ls_data.
          ls_data-mereqitemdummy = 'X'.
          APPEND ls_data TO my_table.
        ENDDO.

      ENDIF.

      my_table_old = my_table.
      SORT my_table_old BY objref.
      my_dirty_flag = mmpur_yes.

      IF my_current_model NE l_new_current.
        CALL METHOD me->if_multiple_model_holder_mm~set_current_model(
          l_new_current ).
      ENDIF.

    ENDIF.
  ENDMETHOD.                    "transport_from_model

  METHOD transport_to_model.
    DATA: ls_data LIKE LINE OF my_table,
          ls_data_old LIKE ls_data,
          l_mereqi  TYPE mereq_item,
          l_mereqix TYPE mereq_itemx,
          ls_data_req LIKE ls_data,
          l_req_item TYPE REF TO if_purchase_requisition_item,
          l_null     TYPE REF TO if_purchase_requisition_item,
          l_check_hidden_fields TYPE mmpur_bool VALUE mmpur_no.

    FIELD-SYMBOLS: <hiddenfields> TYPE table.

    ASSIGN gt_table_hidden_fields->* TO <hiddenfields>.
    IF sy-subrc IS INITIAL.
      IF NOT <hiddenfields>[] IS INITIAL.
        l_check_hidden_fields = mmpur_yes.
      ENDIF.
    ENDIF.

    mmpur_dynamic_cast l_req_item im_model.

    IF NOT l_req_item IS INITIAL.
      READ TABLE my_table INTO ls_data
              WITH KEY objref = l_req_item.

      CHECK sy-subrc IS INITIAL.

      IF l_check_hidden_fields EQ mmpur_yes.
        READ TABLE <hiddenfields> INTO ls_data_old
              WITH KEY ('OBJREF') = l_req_item.
      ENDIF.

      IF l_check_hidden_fields EQ mmpur_no OR
         NOT sy-subrc IS INITIAL.
        READ TABLE my_table_old INTO ls_data_old
              WITH KEY objref = l_req_item     BINARY SEARCH.
        IF NOT sy-subrc IS INITIAL.
          CALL METHOD conversions_output
            EXPORTING
              im_item = my_proposed_item
              im_obj  = l_null
            IMPORTING
              ex_data = ls_data_old.
        ENDIF.

      ENDIF.

*      IF NOT cl_ops_switch_check=>mm_sfws_p2pse( ) IS INITIAL. "EhP4  CCM
*
** clear ERP-contract number in case central contract number was changed
*        IF ls_data-srm_contract_id NE ls_data_old-srm_contract_id
*          OR ls_data-srm_contract_itm NE ls_data_old-srm_contract_itm.
*
*          CLEAR : ls_data-konnr,
*                  ls_data-ktpnr,
*                  ls_data-srm_contract_itm.
*        ENDIF.
*      ENDIF.

      l_mereqi = l_req_item->get_data( ).
      l_mereqix = l_req_item->get_datax( ).

* value from pers. setting                                  "1871265
      IF me->my_proposed_item-lfdat IS NOT INITIAL.
        l_mereqix-lfdat = mmpur_yes.
      ENDIF.
      IF ls_data-eeind IS INITIAL OR ls_data_old-eeind IS INITIAL.
        l_mereqix-lfdat = mmpur_no.
      ENDIF.

      MOVE-CORRESPONDING l_mereqi TO ls_data_req.

      mmpur_transport_fields_x ls_data
                               ls_data_old
                               ls_data_req
                               l_mereqix.

      IF ls_data-eeind NE ls_data_old-eeind.                "646686
        l_mereqix-lfdat = mmpur_yes.
      ENDIF.

      MOVE-CORRESPONDING ls_data_req TO l_mereqi.
      CLEAR l_mereqi-mereqitemdummy.

      CALL METHOD l_req_item->set_data( l_mereqi ).
      CALL METHOD l_req_item->set_datax( l_mereqix ).
    ENDIF.
  ENDMETHOD.                    "transport_to_model

  METHOD pai.
    CALL METHOD super->pai.
    CALL METHOD transport_from_alv.
    CALL METHOD merge_changes.
  ENDMETHOD.                    "pai

  METHOD can_accept.

    DATA: l_model TYPE REF TO if_purchase_requisition_item.

    mmpur_dynamic_cast l_model im_model.
    IF l_model IS INITIAL.
      RAISE cannot_accept.
    ENDIF.

  ENDMETHOD.                    "can_accept

  METHOD notify_row_changed.

    FIELD-SYMBOLS: <a_row> TYPE mereq3211grid.

    CHECK im_row_id NE 0.

    READ TABLE my_table ASSIGNING <a_row> INDEX im_row_id.

    IF sy-subrc IS INITIAL.
      <a_row>-alv_data_changed = mmpur_yes.
    ENDIF.

  ENDMETHOD.                    "notify_row_changed

  METHOD transport_from_alv.

    DATA: l_req_item TYPE REF TO if_purchase_requisition_item,
          lt_req_items LIKE my_copied_items,
          l_proposed_data TYPE mereq3211grid,
          l_old_data      TYPE mereq3211grid,
          l_null          TYPE REF TO if_purchase_requisition_item.


    FIELD-SYMBOLS: <a_row> TYPE mereq3211grid.

    LOOP AT my_table ASSIGNING <a_row>
       WHERE alv_data_changed EQ mmpur_yes.

      l_req_item = <a_row>-objref.
      CLEAR l_old_data.

      IF l_req_item IS INITIAL.
        IF NOT <a_row>-ref_banfn IS INITIAL.
*         create_by_reference
          lt_req_items =
          copy_with_reference( im_banfn = <a_row>-ref_banfn
                               im_bnfpo = <a_row>-ref_bnfpo ).

          APPEND LINES OF lt_req_items TO my_copied_items.

          CONTINUE.                    "no notify data changed
        ELSE.
*         empty row; create a new object
          <a_row>-objref = l_req_item = my_req->create_item( ).

          CALL METHOD conversions_output
            EXPORTING
              im_item = my_proposed_item
              im_obj  = l_null
            IMPORTING
              ex_data = l_old_data.

        ENDIF.
      ELSE.
        READ TABLE my_table_old INTO l_old_data
            WITH KEY objref = l_req_item  BINARY SEARCH.
        IF NOT sy-subrc IS INITIAL.
          CALL METHOD conversions_output
            EXPORTING
              im_item = my_proposed_item
              im_obj  = l_null
            IMPORTING
              ex_data = l_old_data.

        ENDIF.
      ENDIF.

      IF NOT l_req_item IS INITIAL.
        CALL METHOD conversions_input
          EXPORTING
            im_data_old = l_old_data
          CHANGING
            ch_data     = <a_row>.
        CALL METHOD notify_data_changed( l_req_item ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "transport_from_alv

  METHOD transport_from_catalog.

    DATA: l_req_item      TYPE REF TO if_purchase_requisition_item,
          l_requisition   TYPE REF TO if_purchase_requisition,
          l_proposed_data TYPE mereq3211grid,
          l_old_data      TYPE mereq3211grid,
          ls_model        TYPE mmpur_model_type,
          lt_model        TYPE mmpur_models,
          l_null          TYPE REF TO if_purchase_requisition_item,
          l_mereqi        TYPE mereq_item,
          l_mereqix       TYPE mereq_itemx,
          lv_mapval       TYPE oci_srv_map_info,
          lr_oci_srv_info TYPE REF TO cl_oci_map_srv_info.

    FIELD-SYMBOLS: <a_row> TYPE mereq3211grid,
                   <a_cat_row> TYPE item_catalog_data_type.

    LOOP AT im_item_table ASSIGNING <a_cat_row>.

      l_req_item = <a_cat_row>-data-objref.
      CLEAR l_old_data.

      IF l_req_item IS INITIAL.

*       empty row; create a new object
        <a_cat_row>-data-objref = l_req_item = my_req->create_item( ).

        CALL METHOD conversions_output
          EXPORTING
            im_item = my_proposed_item
            im_obj  = l_null
          IMPORTING
            ex_data = l_old_data.


        " Set packno and item ref in helper class
        IF <a_cat_row>-data-packno IS NOT INITIAL AND
           cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.

          CALL METHOD cl_oci_map_srv_info=>get_instance
            RECEIVING
              rr_instance = lr_oci_srv_info.

          IF lr_oci_srv_info IS NOT INITIAL .

            lv_mapval-packno = <a_cat_row>-data-packno.
            lv_mapval-ref    = l_req_item.

            CALL METHOD lr_oci_srv_info->set_mapval
              EXPORTING
                im_map_val = lv_mapval.

          ENDIF.

          CLEAR <a_cat_row>-data-packno.
        ENDIF.

      ELSE.

        READ TABLE my_table_old INTO l_old_data
            WITH KEY objref = l_req_item  BINARY SEARCH.
        IF NOT sy-subrc IS INITIAL.
          CALL METHOD conversions_output
            EXPORTING
              im_item = my_proposed_item
              im_obj  = l_null
            IMPORTING
              ex_data = l_old_data.

        ENDIF.
      ENDIF.

      IF NOT l_req_item IS INITIAL.
        READ TABLE my_table ASSIGNING <a_row>
             WITH KEY objref = l_req_item.
        IF sy-subrc IS NOT INITIAL.
          READ TABLE my_table ASSIGNING <a_row>
               WITH KEY objref = l_null.
          IF NOT sy-subrc IS INITIAL.              "v_n_1063769
            l_old_data-mereqitemdummy = 'X'.
            APPEND l_old_data TO my_table.
            READ TABLE my_table ASSIGNING <a_row>
               WITH KEY objref = l_null.
          ENDIF.                                   "^_n_1063769
        ENDIF.
        IF sy-subrc IS INITIAL.
          IF <a_row> NE <a_cat_row>-data.
            <a_row> = <a_cat_row>-data.
            <a_row>-alv_data_changed = mmpur_yes.
            me->my_trans_from_catalog = 'X'.                "1551196
            CALL METHOD conversions_input
              EXPORTING
                im_data_old = l_old_data
              CHANGING
                ch_data     = <a_row>.
            CLEAR me->my_trans_from_catalog.                "155119
          ENDIF.
        ENDIF.

*       text handling
*       only text deletion is possible at this point, new and changed
*       texts will processed at event 'EXECUTE' because copy rules
        DATA: lr_text          TYPE REF TO if_longtexts_mm,
              l_type           TYPE mmpur_t_texttypes,
              ls_catalog_texts TYPE catalog_text_type.

        FIELD-SYMBOLS: <text> TYPE mmpur_textlines.

        CHECK NOT <a_cat_row>-text IS INITIAL.
*       distinuish between insert and delete
        LOOP AT <a_cat_row>-text ASSIGNING <text>.
          IF NOT <text>-tdline IS INITIAL.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF <text>-tdline IS INITIAL.
          IF NOT l_old_data-bnfpo IS INITIAL.
            mmpur_dynamic_cast lr_text l_req_item.
            IF lr_text IS BOUND.
*             get all available text types
              l_req_item->if_longtexts_mm~get_types(
                                   IMPORTING ex_texttypes = l_type ).
              IF NOT l_type[] IS INITIAL.
                READ TABLE l_type WITH KEY tdid = <text>-tdid
                                  TRANSPORTING NO FIELDS.
                IF sy-subrc IS INITIAL.
                  CALL METHOD lr_text->delete_text( <text>-tdid ).
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.
        ELSE.
          ls_catalog_texts-objref  = l_req_item.
          ls_catalog_texts-lines   = <a_cat_row>-text.
          APPEND ls_catalog_texts TO my_catalog_texts.
        ENDIF.

      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "transport_from_catalog

  METHOD merge_changes.

    DATA: wa LIKE LINE OF my_copied_items,
          l_model TYPE REF TO if_model_mm.

    LOOP AT my_copied_items INTO wa.

      mmpur_dynamic_cast l_model wa-item.
      CALL METHOD notify_data_changed( l_model ).

    ENDLOOP.

    REFRESH my_copied_items.

  ENDMETHOD.                    "merge_changes

  METHOD subject_changed.
    DATA: l_result    TYPE mmpur_bool,
          l_dirty_fs  TYPE mmpur_bool,
          l_model     TYPE REF TO if_model_mm.

    FIELD-SYMBOLS: <ch_entry> LIKE LINE OF changelist.

* 1. handle general information in a super class
    CALL METHOD super->subject_changed(
        sender     = sender
        changelist = changelist ).

* 2. special treatment for that class
    IF sender EQ my_req.

      l_model ?= sender.

      LOOP AT changelist ASSIGNING <ch_entry>
                       WHERE model  EQ l_model.
        CHECK <ch_entry>-action EQ mmchp_chp_container OR
              <ch_entry>-action EQ mmchp_chp_update.        "678433
        l_dirty_fs = mmpur_yes.
        EXIT.
      ENDLOOP.

      IF l_dirty_fs EQ mmpur_yes.

        CALL METHOD transport_from_model( my_model ).

      ENDIF.

    ENDIF.
  ENDMETHOD.                    "subject_changed

  METHOD conversions_output.

    DATA: l_if_msg          TYPE REF TO if_message_obj_mm,
          l_message_handler TYPE REF TO cl_message_handler_mm,
          l_severity        TYPE i.

    CLEAR ex_data.
    MOVE-CORRESPONDING im_item TO ex_data.

* error severity
    mmpur_dynamic_cast l_if_msg im_obj.
    IF NOT l_if_msg IS INITIAL.
* if im_obj is a proxy we have to take the real object!
      DATA: l_proxy TYPE REF TO cl_req_item_proxy_mm.
      mmpur_dynamic_cast l_proxy im_obj.
      IF NOT l_proxy IS INITIAL.
        IF NOT l_proxy->my_real_object IS INITIAL.
          mmpur_dynamic_cast l_if_msg l_proxy->my_real_object.
        ENDIF.
      ENDIF.
      CALL METHOD cl_message_handler_mm=>get_handler
        IMPORTING
          ex_handler = l_message_handler.
      l_severity = l_message_handler->get_severity_bo(
                           im_business_obj          = l_if_msg
                           im_include_child_objects = mmpur_yes ).
    ENDIF.


* item category
    CALL METHOD my_converter->convert_pstyp_output
      EXPORTING
        im_pstyp = im_item-pstyp
      IMPORTING
        ex_epstp = ex_data-epstp.
* plant
    CALL METHOD my_converter->convert_plant_output
      EXPORTING
        im_werks = im_item-werks
      IMPORTING
        ex_name1 = ex_data-name1.
* material group
    CALL METHOD my_converter->convert_matkl_output
      EXPORTING
        im_matkl = im_item-matkl
      IMPORTING
        ex_wgbez = ex_data-wgbez.
* storage location
    CALL METHOD my_converter->convert_lgort_output
      EXPORTING
        im_werks = im_item-werks
        im_lgort = im_item-lgort
      IMPORTING
        ex_lgobe = ex_data-lgobe.

* Conversion of Supplying Sloc and Reswk
*   Convert supplying plant
    CALL METHOD my_converter->convert_plant_output
      EXPORTING
        im_werks = im_item-reswk
      IMPORTING
        ex_name1 = ex_data-reswk_bez.
*   convert supplying sloc
    CALL METHOD my_converter->convert_lgort_output
      EXPORTING
        im_werks = im_item-reswk
        im_lgort = im_item-reslo
      IMPORTING
        ex_lgobe = ex_data-reslo_bez.

* Statusicon
    CALL METHOD my_converter->convert_loekz_output
      EXPORTING
        im_loekz  = im_item-loekz
      IMPORTING
        ex_status = ex_data-statusicon.
    IF ex_data-statusicon IS INITIAL.
      CASE l_severity.
        WHEN mmpur_event_e.
          ex_data-statusicon = my_icon_led_red.
        WHEN mmpur_event_w OR
             mmpur_event_i OR
             mmpur_event_s.
          ex_data-statusicon = my_icon_led_yellow.
      ENDCASE.
    ENDIF.

* Textflagicon
* it is always set, but the fieldselection switches it off/on
    ex_data-textflag = lcl_converter=>c_icon_display_text.

* del. date
    CALL METHOD my_converter->convert_eindt_output
      EXPORTING
        im_lpein = im_item-lpein
        im_eindt = im_item-lfdat
      IMPORTING
        ex_elpei = ex_data-elpei
        ex_eeind = ex_data-eeind.

* dcm processing state
    CALL METHOD my_converter->convert_banpricon_output
      EXPORTING
        im_banpr     = im_item-banpr
        im_obj       = im_obj
      IMPORTING
        ex_banpricon = ex_data-banpricon.

  ENDMETHOD.                    "conversions_output


  METHOD conversions_input.

* 1. plant
* Only run in case we are not coming from transport_from_catalog "^1831850
* otherwise the value is overwritten by the second run
    IF me->my_trans_from_catalog IS INITIAL.
      IF im_data_old-name1 NE ch_data-name1.
        CALL METHOD my_converter->convert_plant
          CHANGING
            ch_werks = ch_data-werks
            ch_name  = ch_data-name1.
      ENDIF.
    ENDIF.                                                  "v1831850

* 2. Storage location
    IF im_data_old-lgobe NE ch_data-lgobe.
      CALL METHOD my_converter->convert_lgort
        CHANGING
          ch_werks = ch_data-werks
          ch_name  = ch_data-name1
          ch_lgort = ch_data-lgort
          ch_lgobe = ch_data-lgobe.
    ENDIF.

* Conversion of Supplying Sloc and Reswk
* 1a. Supplying plant
    IF im_data_old-reswk_bez NE ch_data-reswk_bez.
      CALL METHOD my_converter->convert_plant
        CHANGING
          ch_werks = ch_data-reswk
          ch_name  = ch_data-reswk_bez.
    ENDIF.

* 2a. Supplying Storage Loc.
    IF im_data_old-reslo_bez NE ch_data-reslo_bez.
      CALL METHOD my_converter->convert_lgort
        CHANGING
          ch_werks = ch_data-reswk
          ch_name  = ch_data-reswk_bez
          ch_lgort = ch_data-reslo
          ch_lgobe = ch_data-reslo_bez.
    ENDIF.

* 3. material group
* Only run in case we are not coming from transport_from_catalog "^1551196
* otherwise the value is overwritten by the second run
    IF me->my_trans_from_catalog IS INITIAL.                "v1551196
      IF im_data_old-wgbez NE ch_data-wgbez.
        CALL METHOD my_converter->convert_matkl
          CHANGING
            ch_matkl = ch_data-matkl
            ch_wgbez = ch_data-wgbez.

      ENDIF.
    ENDIF.                                                  "1551196

* 4. item category
    IF im_data_old-epstp NE ch_data-epstp.
      CALL METHOD my_converter->convert_pstyp
        CHANGING
          ch_pstyp = ch_data-pstyp
          ch_epstp = ch_data-epstp.
    ENDIF.

* 5a. Material number
    IF im_data_old-matnr NE ch_data-matnr AND
       ch_data-matnr NE space.
      CALL METHOD my_converter->convert_matnr
        CHANGING
          ch_matnr = ch_data-matnr.
    ENDIF.
* 5b. ematn
    IF im_data_old-ematn NE ch_data-ematn AND
       ch_data-ematn NE space.
      CALL METHOD my_converter->convert_matnr
        CHANGING
          ch_matnr = ch_data-ematn.
    ENDIF.

* 6. del. date
    IF im_data_old-elpei NE ch_data-elpei OR
       im_data_old-eeind NE ch_data-eeind.

      CLEAR: ch_data-lpein, ch_data-lfdat.                  "646686
      CALL METHOD my_converter->convert_eindt
        CHANGING
          ch_lpein = ch_data-lpein
          ch_eindt = ch_data-lfdat
          ch_elpei = ch_data-elpei
          ch_eeind = ch_data-eeind.

    ENDIF.

  ENDMETHOD.                    "conversions_input

  METHOD toolbar_init.

    DATA: lt_my_buttons LIKE ch_buttons,
          l_quick       TYPE iconquick,
          l_menu        TYPE REF TO cl_ctmenu,
          ls_menu       TYPE stb_btnmnu,
          lt_fieldselection TYPE ttyp_fieldselection_mm,    "635554
          l_fs_entry  LIKE LINE OF lt_fieldselection,
          l_metafield TYPE mmpur_metafield,
          l_disabled,     "X -> only display
          l_delete,       "X -> only display; N -> no display
          l_unlock,       "X -> only display; N -> no display
          ls_basic_cfg    TYPE wsdt_basic_cfg.

    CALL METHOD super->toolbar_init
      CHANGING
        ch_buttons = ch_buttons
        ch_menues  = ch_menues.

* Build fs table: mmmfd_item_copy, mmmfd_delete_item, ...     HW 635554
    CLEAR l_fs_entry.
    l_fs_entry-metafield = mmmfd_item_copy.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.
    l_fs_entry-metafield = mmmfd_delete_item.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.
    l_fs_entry-metafield = mmmfd_lock_item.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.
    l_fs_entry-metafield = mmmfd_unlock_item.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.
    l_fs_entry-metafield = mmmfd_catalog.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.
    l_fs_entry-metafield = mmmfd_serno_list.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.
    l_fs_entry-metafield = mmmfd_mat_search.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.

    CALL METHOD my_req->if_fieldselection_mm~fs_get
      CHANGING
        ch_fieldselection = lt_fieldselection.

    l_quick = text-r08.

    CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
      EXPORTING
        fcode            = '&MEREQDETAIL'
        icon             = icon_select_detail
*       DISABLED         =
        butn_type        = cntb_btype_button
*       TEXT             =
        quickinfo        = l_quick
*       CHECKED          =
      CHANGING
        data_table       = lt_my_buttons
      EXCEPTIONS
        cntb_btype_error = 1
        OTHERS           = 2.

    CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
      EXPORTING
        fcode            = '&&MESEP01'
        icon             = space
*       DISABLED         =
        butn_type        = cntb_btype_sep
*       TEXT             =
*       QUICKINFO        =
*       CHECKED          =
      CHANGING
        data_table       = lt_my_buttons
      EXCEPTIONS
        cntb_btype_error = 1
        OTHERS           = 2.

*DCM exclude functions
    DATA: l_document TYPE mepo_document.
    IF NOT my_req IS INITIAL.
      CALL METHOD my_req->get_transaction_state
        IMPORTING
          ex_document = l_document.
    ENDIF.

    IF my_req IS INITIAL OR my_req->get_activity( ) NE anz.

      IF l_document-initiator-initiator NE mmpur_initiator_ba AND
         l_document-initiator-initiator NE mmpur_initiator_rel.

* Determine field status for mmmfd_item_copy                  HW 635554
        CLEAR: l_fs_entry, l_disabled.
        READ TABLE lt_fieldselection
                              WITH KEY metafield = mmmfd_item_copy
                              INTO l_fs_entry.
        IF l_fs_entry-fieldstatus NE '-'.
          IF l_fs_entry-fieldstatus EQ '*'.
            l_disabled = mmpur_yes.
          ENDIF.

          l_quick = text-r11.

          CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
            EXPORTING
              fcode            = '&MEREQCOPY'
              icon             = icon_copy_object
              disabled         = l_disabled                 "635554
              butn_type        = cntb_btype_button
*             TEXT             =
              quickinfo        = l_quick
*             CHECKED          =
            CHANGING
              data_table       = lt_my_buttons
            EXCEPTIONS
              cntb_btype_error = 1
              OTHERS           = 2.
        ENDIF.

*      l_quick = text-r24.
*
*      CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
*         EXPORTING
*           fcode            = '&MEREQMASS'
*           icon             = ICON_MASS_CHANGE
**          DISABLED         =
*           butn_type        = cntb_btype_button
**           text             =
*           quickinfo        = l_quick
**          CHECKED          =
*         CHANGING
*           data_table       = lt_my_buttons
*         EXCEPTIONS
*           cntb_btype_error = 1
*           OTHERS           = 2.
      ENDIF.

      IF l_document-initiator-initiator NE mmpur_initiator_ba.

* Determine field status for mmmfd_delete_item and            HW 635554
* mmmfd_unlock_item
        CLEAR: l_fs_entry, l_disabled, l_delete, l_unlock.
        READ TABLE lt_fieldselection
                              WITH KEY metafield = mmmfd_delete_item
                              INTO l_fs_entry.
        IF l_fs_entry-fieldstatus EQ '-'.
          l_delete = 'N'.
        ELSEIF l_fs_entry-fieldstatus EQ '*'.
          l_delete = mmpur_yes.
        ENDIF.
        READ TABLE lt_fieldselection
                              WITH KEY metafield = mmmfd_unlock_item
                              INTO l_fs_entry.
        IF l_fs_entry-fieldstatus EQ '-'.
          l_unlock = 'N'.
        ELSEIF l_fs_entry-fieldstatus EQ '*'.
          l_unlock = mmpur_yes.
        ENDIF.

        IF NOT ( l_delete EQ 'N' AND l_unlock EQ 'N' ).
          IF l_delete EQ mmpur_yes AND l_unlock EQ mmpur_yes.
            l_disabled = mmpur_yes.
          ENDIF.

          l_quick = text-r09.

          CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
            EXPORTING
              fcode            = '&MEREQDELETE'
              icon             = icon_delete
              disabled         = l_disabled                 "635554
              butn_type        = cntb_btype_dropdown
*             TEXT             =
              quickinfo        = l_quick
*             CHECKED          =
            CHANGING
              data_table       = lt_my_buttons
            EXCEPTIONS
              cntb_btype_error = 1
              OTHERS           = 2.

          IF l_delete IS INITIAL OR l_unlock IS INITIAL.
            CREATE OBJECT l_menu.
            IF l_delete NE 'N'.
              CLEAR l_disabled.
              IF l_delete EQ mmpur_yes.
                l_disabled = mmpur_yes.
              ENDIF.
              CALL METHOD l_menu->add_function
                EXPORTING
                  fcode    = '&MEREQDELETE'
                  text     = text-r09
                  disabled = l_disabled.                    "635554
            ENDIF.
            IF l_unlock NE 'N'.
              CLEAR l_disabled.
              IF l_unlock EQ mmpur_yes.
                l_disabled = mmpur_yes.
              ENDIF.
              CALL METHOD l_menu->add_function
                EXPORTING
                  fcode    = '&MEREQUNDELETE'
                  text     = text-r10
                  disabled = l_disabled.                    "635554
            ENDIF.

            ls_menu-function = '&MEREQDELETE'.
            ls_menu-ctmenu   = l_menu.

            APPEND ls_menu TO ch_menues.

          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.

    CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
      EXPORTING
        fcode            = '&&MESEP02'
        icon             = space
*       DISABLED         =
        butn_type        = cntb_btype_sep
*       TEXT             =
*       QUICKINFO        =
*       CHECKED          =
      CHANGING
        data_table       = lt_my_buttons
      EXCEPTIONS
        cntb_btype_error = 1
        OTHERS           = 2.

    INSERT LINES OF lt_my_buttons INTO ch_buttons INDEX 1.

*
* now the functions, which belong to the end of the toolbar
*
    REFRESH lt_my_buttons.

    CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
      EXPORTING
        fcode            = '&&MESEP03'
        icon             = space
*       DISABLED         =
        butn_type        = cntb_btype_sep
*       TEXT             =
*       QUICKINFO        =
*       CHECKED          =
      CHANGING
        data_table       = lt_my_buttons
      EXCEPTIONS
        cntb_btype_error = 1
        OTHERS           = 2.

*DCM exclude for buyer
    IF l_document-initiator-initiator NE mmpur_initiator_ba.

      l_quick = text-r05.

      CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
        EXPORTING
          fcode            = '&MESOURCEASSIGNALL'
          icon             = icon_import
*         DISABLED         =
          butn_type        = cntb_btype_button
*         text             = text-r05
          quickinfo        = l_quick
*         CHECKED          =
        CHANGING
          data_table       = lt_my_buttons
        EXCEPTIONS
          cntb_btype_error = 1
          OTHERS           = 2.
*DCM
    ENDIF.

    l_quick = text-r21.

    CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
      EXPORTING
        fcode            = '&MEREQAVAIL'
        icon             = icon_availability_check
*       DISABLED         =
        butn_type        = cntb_btype_button
*       text             = text-r21
        quickinfo        = l_quick
*       CHECKED          =
      CHANGING
        data_table       = lt_my_buttons
      EXCEPTIONS
        cntb_btype_error = 1
        OTHERS           = 2.

*DCM exclude for buyer
    IF l_document-initiator-initiator NE mmpur_initiator_ba.

      l_quick = text-r22.

      CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
        EXPORTING
          fcode            = '&MEREQDMS'
          icon             = icon_attachment
*         DISABLED         =
          butn_type        = cntb_btype_button
*         text             = text-r21
          quickinfo        = l_quick
*         CHECKED          =
        CHANGING
          data_table       = lt_my_buttons
        EXCEPTIONS
          cntb_btype_error = 1
          OTHERS           = 2.

* Single release: release all selected items
      DATA: ls_data       LIKE LINE OF my_table,
            l_item        TYPE mereq_item,
            lt_items      TYPE mmpur_requisition_items,
            l_release     TYPE mmpur_bool VALUE mmpur_no.

      IF l_document-initiator-initiator EQ mmpur_initiator_rel AND
        my_req->get_activity( ) NE anz.
        lt_items = my_req->get_items( im_auth_check = mmpur_yes
                                      im_release_op = mmpur_yes ).
        IF NOT lt_items[] IS INITIAL.
          CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
            EXPORTING
              fcode            = '&&MESEP03'
              icon             = space
              butn_type        = cntb_btype_sep
            CHANGING
              data_table       = lt_my_buttons
            EXCEPTIONS
              cntb_btype_error = 1
              OTHERS           = 2.

          l_quick = text-x02.
          CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
            EXPORTING
              fcode            = '&MEREQRELALL'
              icon             = icon_release
              butn_type        = cntb_btype_button
              quickinfo        = l_quick
            CHANGING
              data_table       = lt_my_buttons
            EXCEPTIONS
              cntb_btype_error = 1
              OTHERS           = 2.
          IF my_release_filter_on EQ mmpur_no.
            l_quick = text-x05.
            CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
              EXPORTING
                fcode            = '&MEREQRELPROP'
                icon             = icon_select_with_condition
                butn_type        = cntb_btype_button
                quickinfo        = l_quick
              CHANGING
                data_table       = lt_my_buttons
              EXCEPTIONS
                cntb_btype_error = 1
                OTHERS           = 2.
          ELSE.
            l_quick = text-x06.
            CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
              EXPORTING
                fcode            = '&MEREQALLPROP'
                icon             = icon_filter_undo
                butn_type        = cntb_btype_button
                quickinfo        = l_quick
              CHANGING
                data_table       = lt_my_buttons
              EXCEPTIONS
                cntb_btype_error = 1
                OTHERS           = 2.
          ENDIF.
        ENDIF.
      ENDIF.

***DCM new function complete version in all selected items
***    if dcm is active
      DATA: l_activ       TYPE mmpur_bool VALUE mmpur_no.
      DATA: l_adapter     TYPE REF TO if_dcm_adapter.

      IF NOT my_table IS INITIAL AND
      ( my_req IS INITIAL OR my_req->get_activity( ) NE anz ).

        LOOP AT my_table INTO ls_data
             WHERE NOT objref IS INITIAL.
          mmpur_dynamic_cast l_adapter ls_data-objref.
          IF l_adapter->is_complete_version_allowed( ) EQ mmpur_yes.
            l_activ = mmpur_yes.
            EXIT.
          ENDIF.
        ENDLOOP.
        IF l_activ EQ mmpur_yes.
          l_quick = text-x04.

          CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
            EXPORTING
              fcode            = '&MEREQDCMALL'
              icon             = icon_complete
*             DISABLED         =
              butn_type        = cntb_btype_button
*             text             = text-r21
              quickinfo        = l_quick
*             CHECKED          =
            CHANGING
              data_table       = lt_my_buttons
            EXCEPTIONS
              cntb_btype_error = 1
              OTHERS           = 2.
        ENDIF.
      ENDIF.
    ENDIF.


    CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
      EXPORTING
        fcode            = '&&MESEP04'
        icon             = space
*       DISABLED         =
        butn_type        = cntb_btype_sep
*       TEXT             =
*       QUICKINFO        =
*       CHECKED          =
      CHANGING
        data_table       = lt_my_buttons
      EXCEPTIONS
        cntb_btype_error = 1
        OTHERS           = 2.

    l_quick = text-r12.

    CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
      EXPORTING
        fcode            = '&MEITPRP'
        icon             = icon_personal_settings
*       DISABLED         =
        butn_type        = cntb_btype_button
        text             = text-r12
        quickinfo        = l_quick
*       CHECKED          =
      CHANGING
        data_table       = lt_my_buttons
      EXCEPTIONS
        cntb_btype_error = 1
        OTHERS           = 2.

* Determine field status for mmmfd_catalog
    CLEAR: l_fs_entry, l_disabled.
    READ TABLE lt_fieldselection
                          WITH KEY metafield = mmmfd_catalog
                          INTO l_fs_entry.
    IF l_fs_entry-fieldstatus NE '-'.
      IF l_fs_entry-fieldstatus EQ '*'.
        l_disabled = mmpur_yes.
      ENDIF.

      l_quick = text-r13.

      CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
        EXPORTING
          fcode            = '&MEREQCATALOG'
          icon             = icon_catalog
          disabled         = l_disabled
          butn_type        = cntb_btype_button
*         text             = text-r13
          quickinfo        = l_quick
*         CHECKED          =
        CHANGING
          data_table       = lt_my_buttons
        EXCEPTIONS
          cntb_btype_error = 1
          OTHERS           = 2.

    ENDIF.

* Serial Number button
    CLEAR: l_fs_entry.
    READ TABLE lt_fieldselection
                              WITH KEY metafield = mmmfd_serno_list
                              INTO l_fs_entry.
    IF l_fs_entry-fieldstatus NE '-'.
      l_quick = text-r32.

      CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
        EXPORTING
          fcode            = '&SN_OVERVIEW'
          icon             = icon_object_list
          butn_type        = cntb_btype_button
          quickinfo        = l_quick
        CHANGING
          data_table       = lt_my_buttons
        EXCEPTIONS
          cntb_btype_error = 1
          OTHERS           = 2.

    ENDIF.

* EHP5 -> extended document flow
    IF cl_ops_switch_check=>mm_sfws_ci_3( ) = abap_true.
      CLEAR: l_fs_entry.
*      READ TABLE lt_fieldselection
*                                WITH KEY metafield = mmmfd_serno_list
*                                INTO l_fs_entry.
*      IF l_fs_entry-fieldstatus NE '-'.
      l_quick = text-r52.
      CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
        EXPORTING
          fcode            = 'MEDIDOCF'
          icon             = icon_te_receipts
          butn_type        = cntb_btype_button
          quickinfo        = l_quick
        CHANGING
          data_table       = lt_my_buttons
        EXCEPTIONS
          cntb_btype_error = 1
          OTHERS           = 2.
*      ENDIF.
    ENDIF.
* Determine field status for mmmfd_catalog
    IF cl_ops_switch_check=>mm_sfws_mat_search( ) = abap_true.
      CLEAR: l_fs_entry, l_disabled.
      ls_basic_cfg = cl_wsd_config=>read_mat_basic_config( i_app_name = cl_wsd_constants=>co_appl_purchase_order ).
      IF ls_basic_cfg-so_active IS NOT INITIAL.
        READ TABLE lt_fieldselection
                              WITH KEY metafield = mmmfd_mat_search
                              INTO l_fs_entry.
        IF l_fs_entry-fieldstatus NE '-'.
          IF l_fs_entry-fieldstatus EQ '*'.
            l_disabled = mmpur_yes.
          ENDIF.

          l_quick = text-r53.

          CALL METHOD cl_gui_toolbar=>fill_buttons_data_table
            EXPORTING
              fcode            = '&MEREQEXTMATSEARCH'
              icon             = icon_extended_search
              disabled         = l_disabled
              butn_type        = cntb_btype_button
*             text             = text-r13
              quickinfo        = l_quick
*             CHECKED          =
            CHANGING
              data_table       = lt_my_buttons
            EXCEPTIONS
              cntb_btype_error = 1
              OTHERS           = 2.

        ENDIF.
      ENDIF.
    ENDIF.


    APPEND LINES OF lt_my_buttons TO ch_buttons.
  ENDMETHOD.                    "toolbar_init

  METHOD execute.

    DATA: l_fcode TYPE sy-ucomm VALUE 'MEREQFLUSH'.

    CALL METHOD super->execute
      CHANGING
        im_fcode = im_fcode.

    CASE im_fcode.
      WHEN '&MEREQDETAIL'.
        CALL METHOD select_detail.
*        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).
      WHEN '&MEREQRELALL'.
        CALL METHOD release_selection.
      WHEN '&MEREQRELPROP'.
        CALL METHOD release_set_selection( im_release_filter = mmpur_yes ).
      WHEN '&MEREQALLPROP'.
        CALL METHOD release_set_selection( im_release_filter = mmpur_no ).
      WHEN 'MEREQCATALOG'.                                  "n_1308889
        CALL METHOD catalog_texts.
        CLEAR im_fcode.
      WHEN '&SN_OVERVIEW'.
        CALL METHOD serial_list.
    ENDCASE.

  ENDMETHOD.                    "execute

  METHOD define_sort_criteria.

    DATA: ls_sort     LIKE LINE OF ct_sort,
          ls_fieldcat LIKE LINE OF gt_fieldcatalog,
          l_update_grid TYPE mmpur_bool VALUE mmpur_no.

    IF NOT my_grid IS INITIAL.
      CALL METHOD my_grid->get_sort_criteria
        IMPORTING
          et_sort = ct_sort.
    ENDIF.

    READ TABLE ct_sort
      INTO ls_sort WITH KEY fieldname = 'MEREQITEMDUMMY'.
    IF sy-subrc IS INITIAL.
      IF sy-tabix NE 1.
        DELETE ct_sort INDEX sy-tabix.
        INSERT ls_sort INTO ct_sort INDEX 1.
        l_update_grid = mmpur_yes.
      ENDIF.
    ELSE.
      ls_sort-fieldname = 'MEREQITEMDUMMY'.
      ls_sort-up = 'X'.
      ls_sort-spos = 1.
      ls_sort-subtot = ''.
      ls_sort-obligatory = 'X'.
      ls_sort-no_out = 'X'.
      INSERT ls_sort INTO ct_sort INDEX 1.
      l_update_grid = mmpur_yes.
    ENDIF.

    IF NOT my_grid IS INITIAL AND
       l_update_grid EQ mmpur_yes.
      CALL METHOD my_grid->set_sort_criteria( ct_sort ).
    ENDIF.

  ENDMETHOD.                    "define_sort_criteria

  METHOD read_from_catalog.

    DATA: lt_oci_item      TYPE mmpur_oci_cat_return_type_t,
          lt_process_srv   TYPE mmpur_oci_cat_return_type_t,
          ls_oci_item      TYPE mmpur_oci_cat_return_type,
          ls_oci_srv_item  TYPE mmpur_oci_cat_return_type,
          lt_oci_longtext  TYPE wsi_oci_longtext_t,
          ls_oci_longtext  TYPE wsi_oci_longtext_s,
          ls_cat_item      TYPE item_catalog_data_type,
          lv_no_items      TYPE i,
          ls_proposed_item TYPE item_catalog_data_type,
          ls_textline      TYPE mmpur_textlines,
          l_new_item       TYPE mmpur_bool,
          l_header         TYPE REF TO if_purchase_requisition,
          l_header_data    TYPE mereq_header,
          l_tdid           TYPE mmpur_textlines-tdid VALUE 'B01',
          l_tabix          TYPE sy-tabix,
          l_factor         TYPE p DECIMALS 3,

          ls_fs            LIKE LINE OF my_cat_fs,
          l_mfs            TYPE REF TO cl_mfs_mm,
          lt_cat_mapping   TYPE mepo_t_metafield_mapping,
          l_map            LIKE LINE OF my_cat_mapping,
          l_map_error      TYPE mmpur_bool,

          l_badi           TYPE REF TO me_catalog_interface,
          lo_badi_cust     TYPE REF TO me_catalog_interface_cust,
          l_item_descr     TYPE REF TO cl_abap_structdescr,
          l_catalog_descr  TYPE REF TO cl_abap_structdescr,
          ls_map_fields    TYPE mecat_fieldmap,
          lt_map_fields    TYPE mecat_fieldmap_tab.

    DATA: lt_oci_item_srv          TYPE mmpur_oci_cat_return_type_t,
          lv_packno                TYPE comsrv-packno,
          lv_logical_system_name   TYPE tbdls-logsys,
          lr_cl_mmbsi_cc_conv      TYPE REF TO cl_mmbsi_cc_conv,
          lv_contract_item         TYPE bbp_itemno,
          lv_erp_contract_item     TYPE ebelp,
          lv_srm_flag              TYPE abap_bool,
          lv_srm_contract_id       TYPE bbp_itemno,
          lv_srvmapkey             TYPE srvmapkey,
          lv_line                  TYPE i,
          lv_parent_new            TYPE wsi_oci_line.

    FIELD-SYMBOLS: <source>   TYPE any,
                   <target>   TYPE any,
                   <s_target> TYPE any,
                   <mapping>  TYPE abap_compdescr.

    "Get Logical System Name
    CALL FUNCTION 'OWN_LOGICAL_SYSTEM_GET'
      IMPORTING
        own_logical_system             = lv_logical_system_name
      EXCEPTIONS
        own_logical_system_not_defined = 1
        OTHERS                         = 2.

*
    DEFINE is_input_allowed.
*     &1 - destination field
*     lt_fs - lokal table fieldselection (metafield - fieldstatus)
*     my_cat_mapping - table fieldmapping (fieldname - metafield)
      read table my_cat_mapping into l_map
                                with key fieldname = &1.
      if sy-subrc is initial.
        read table my_cat_fs into ls_fs
                             with key metafield = l_map-metafield.
        if sy-subrc is initial.
          if not ( ls_fs-fieldstatus eq '+' or
                   ls_fs-fieldstatus eq '.' or
                   ls_fs-fieldstatus is initial ).
            sy-subrc = 1.
          endif.
        endif.
      endif.
    END-OF-DEFINITION.

    DEFINE map.
*     &1 - destination structure
*     &2 - destination field
*     &3 - source value
      is_input_allowed &2.
      if sy-subrc is initial.
        assign component &2 of structure &1 to <target>.
        if sy-subrc is initial.
          <target> = &3.
        endif.
      endif.
    END-OF-DEFINITION.


*--------------------------------------------------------------------*
* new hook for catalog integration
*--------------------------------------------------------------------*
    DATA lo_catalog TYPE REF TO lcl_catalog.

    lo_catalog = lcl_catalog=>get_instance( io_model  = me->my_model
                                            io_parent = me ).

    lo_catalog->read_from_catalog( CHANGING   im_item_table  = im_item_table
                                   EXCEPTIONS illegal_call   = 1
                                              map_error      = 2
                                              no_data_import = 3 ).


*- prepare proposal data for new items -------------------------------*
*   get proposed data for new items and ...
    READ TABLE im_item_table INTO ls_proposed_item
         WITH KEY data-objref = ls_cat_item-data-objref.
*   ... delete entry for proposer from out_tab
    IF sy-tabix GT 0.
      DELETE im_item_table INDEX sy-tabix.
    ENDIF.

*- call catalog interface --------------------------------------------*
    TRY.
        CALL FUNCTION 'MMPUROCI_PRODUCT_SEARCH'
          EXPORTING
*           IMD_WEBSERVICE_ID =
            imd_bstyp        = 'B'
            imd_searchstring = ''
*           IMD_LIFNR        =
            imd_init_call    = mmpur_yes
          IMPORTING
            et_oci_items     = lt_oci_item
            et_oci_longtext  = lt_oci_longtext.
      CATCH cx_mmpur_not_found cx_mmpur_incorrect_customizing.
        RAISE illegal_call.
    ENDTRY.

    IF lt_oci_item IS INITIAL.
      REFRESH im_item_table.
      RAISE no_data_import.
    ENDIF.

    mmpur_dynamic_cast1 l_header me->my_model.
    l_header_data = l_header->get_data( ).

*  get mapping for fieldselection
    IF my_cat_mapping IS INITIAL.
      l_mfs = cl_mfs_mm=>get_instance( ).
      l_mfs->register( EXPORTING  im_application = 'MMPUR_PO_VIEWS'
                       EXCEPTIONS already_registered = 1
                                  failure            = 2 ).
      my_cat_mapping = l_mfs->lookup( im_application = 'MMPUR_PO_VIEWS'
                                      im_tabname     = 'MEREQ3211GRID' ).
      l_mfs->register( EXPORTING  im_application = 'MMPUR_PO_DOC'
                       EXCEPTIONS already_registered = 1
                                  failure            = 2 ).
      lt_cat_mapping = l_mfs->lookup( im_application = 'MMPUR_PO_DOC'
                                      im_tabname     = 'MEREQ_ITEM'
                                      im_fieldname   = 'ITEXT' ).
      LOOP AT lt_cat_mapping INTO l_map.
        READ TABLE my_cat_mapping WITH TABLE KEY application = l_map-application
                                                 tabname     = l_map-tabname
                                                 fieldname   = l_map-fieldname
                                                 TRANSPORTING NO FIELDS.
        INSERT l_map INTO my_cat_mapping INDEX sy-tabix.
        EXIT.
      ENDLOOP.
      LOOP AT my_cat_mapping INTO l_map.
        ls_fs-metafield = l_map-metafield.
        INSERT ls_fs INTO TABLE my_cat_fs.
      ENDLOOP.
    ENDIF.

*- mapping catalog values to req items -------------------------------*
    LOOP AT lt_oci_item INTO ls_oci_item.

      l_tabix = sy-tabix.                                   "1768759
      READ TABLE im_item_table INDEX l_tabix INTO ls_cat_item.
      IF NOT sy-subrc IS INITIAL.
        ls_cat_item = ls_proposed_item.
        l_new_item = mmpur_yes.
      ENDIF.

* -- Service structure download possible only for ehp5 ---------------*
      IF cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.
        CLEAR lv_no_items.
        CLEAR lt_process_srv.
        CLEAR lv_packno.

        IF ls_oci_item-item_type CA 'FRLOI'.                "1768759
          LOOP AT lt_oci_item INTO ls_oci_srv_item.
            lv_parent_new = ls_oci_srv_item-parent_id.

            IF lv_parent_new IS INITIAL.
              lv_no_items = lv_no_items + 1.
              IF lv_no_items > 1.
                EXIT.
              ELSE.
                APPEND  ls_oci_srv_item TO lt_process_srv.
                DELETE lt_oci_item WHERE line = ls_oci_srv_item-line.
              ENDIF.
            ELSE.
              APPEND  ls_oci_srv_item TO lt_process_srv.
              DELETE lt_oci_item WHERE line = ls_oci_srv_item-line.
            ENDIF.

          ENDLOOP.

          IF ( ls_oci_item-service = abap_true ) AND ( ls_oci_item-parent_id EQ 'NULL' ).

          ELSE.

            IF ls_oci_item-item_type CA 'LFI'.
              CONTINUE.
            ELSEIF ls_oci_item-item_type EQ 'O'.
              READ TABLE lt_oci_item WITH KEY item_type = 'R' line = ls_oci_item-parent_id TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CONTINUE.
              ENDIF.
              READ TABLE lt_oci_item WITH KEY item_type = 'O' line = ls_oci_item-parent_id TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
                CONTINUE.
              ENDIF.
            ENDIF.

          ENDIF.
* get account assignment category with consumption indicator unknown 1768759
          SELECT SINGLE knttp FROM t163k INTO ls_proposed_item-data-knttp "#EC *
                              WHERE kzvbr = cl_mmpur_constants=>kzvbr_u.

          IF lines( lt_process_srv ) GT 1.
            CALL FUNCTION 'MS_OCI_ADD_SERVICE_STRUCTURE'
              EXPORTING
                iv_service_info_fill_type = '0'
                it_oci_srv_items          = lt_process_srv
                iv_glob_origin            = '1'
              IMPORTING
                ev_packno                 = lv_packno.
          ENDIF.

        ENDIF.

      ENDIF.


*     get fieldselection for whole item
      IF ls_cat_item-data-objref IS INITIAL.
        CALL METHOD l_header->if_fieldselection_mm~fs_get(
          CHANGING
            ch_fieldselection = my_cat_fs ).
      ELSE.
        CALL METHOD ls_cat_item-data-objref->if_fieldselection_mm~fs_get(
          CHANGING
            ch_fieldselection = my_cat_fs ).
      ENDIF.

*     BAdI 'ME_CATALOG_INTERFACE' to determine field mapping
      TRY.
          REFRESH lt_map_fields.
          GET BADI l_badi.
          l_item_descr ?= cl_abap_structdescr=>describe_by_data(
                                                 ls_cat_item ).
          l_catalog_descr ?= cl_abap_structdescr=>describe_by_data(
                                                    ls_oci_item ).
          CLEAR ls_map_fields.
          CALL BADI l_badi->map_cat_values
            EXPORTING
              im_bstyp                   = 'B'
              im_catalog_structure       = 'ls_oci_item'
              im_catalog_structure_descr = l_catalog_descr
              im_item_structure          = 'ls_cat_item'
              im_item_structure_descr    = l_item_descr
            IMPORTING
              ex_field_map               = lt_map_fields
            CHANGING
              ch_oci_item                = ls_oci_item.
        CATCH cx_badi_not_implemented.
*         nothing
      ENDTRY.

      GET BADI lo_badi_cust. "1768759
      CALL BADI lo_badi_cust->map_catalog_values
        EXPORTING
          iv_bstyp             = 'B'
          iv_catalog_structure = 'ls_oci_item'
          io_rtts_catalog      = l_catalog_descr
          iv_item_structure    = 'ls_cat_item'
          io_rtts_item         = l_item_descr
        CHANGING
          ct_field_map         = lt_map_fields
          ct_oci_item          = ls_oci_item.

*     service flag
      IF ls_oci_item-service EQ mmpur_yes OR ls_oci_item-item_type CA 'RO'.
        is_input_allowed 'EPSTP'.
        IF sy-subrc IS INITIAL.
          ls_cat_item-data-pstyp = cl_mmpur_constants=>pstyp_9. "1768759
          SELECT SINGLE epstp FROM t163y INTO ls_cat_item-data-epstp
                   WHERE pstyp = ls_cat_item-data-pstyp
                     AND spras = sy-langu.
        ENDIF.
      ENDIF.

*     item overview
      map ls_cat_item-data 'WAERS' ls_oci_item-currency.
*      IF NOT ( ls_cat_item-data-pstyp EQ '9' OR
*               ls_cat_item-data-epstp EQ 'D' ).
      map ls_cat_item-data 'MATNR' ls_oci_item-matnr.       "938797
      is_input_allowed 'MENGE'.
      IF sy-subrc IS INITIAL.
        CALL FUNCTION 'ME_MAP_CHAR_TO_PACK'
          EXPORTING
            im_pack = ls_cat_item-data-menge
          CHANGING
            ch_char = ls_oci_item-quantity
          EXCEPTIONS
            OTHERS  = 1.
        TRY.
            ls_cat_item-data-menge = ls_oci_item-quantity.
          CATCH cx_sy_conversion_error cx_sy_arithmetic_error.
*             Fehler bei Datenübernahme von &1 aus dem Katalog in das
*             Feld &2
            MESSAGE i765(me) WITH ls_oci_item-quantity 'MENGE'.
            l_map_error = mmpur_yes.
        ENDTRY.
      ENDIF.
      is_input_allowed 'MEINS'.
      IF sy-subrc IS INITIAL.
        IF NOT ls_oci_item-unit IS INITIAL.
          CALL FUNCTION 'UNIT_OF_MEASURE_ISO_TO_SAP'
            EXPORTING
              iso_code  = ls_oci_item-unit
            IMPORTING
              sap_code  = ls_cat_item-data-meins
            EXCEPTIONS
              not_found = 1
              OTHERS    = 2.
          IF sy-subrc <> 0.
            MESSAGE i851(me) WITH ls_oci_item-unit.
            l_map_error = mmpur_yes.
          ENDIF.
        ELSE.
          CLEAR ls_cat_item-data-meins.
        ENDIF.
      ENDIF.

      map ls_cat_item-data 'PREIS' ls_oci_item-price.       "1782512

      IF ls_oci_item-priceunit IS INITIAL.
        ls_oci_item-priceunit = '1'.
      ENDIF.
      map ls_cat_item-data 'PEINH' ls_oci_item-priceunit.
*      ENDIF.
      map ls_cat_item-data 'TXZ01' ls_oci_item-description.
      IF ls_cat_item-data-matnr IS INITIAL.
        map ls_cat_item-data 'WGBEZ' ls_oci_item-matgroup.
      ENDIF.
      map ls_cat_item-data 'PLIFZ' ls_oci_item-leadtime.
      map ls_cat_item-data 'IDNLF' ls_oci_item-vendormat.

*     source
      IF l_header_data-bsakz EQ 'T'.
        map ls_cat_item-data 'RESWK' ls_oci_item-vendor.
      ELSE.
        map ls_cat_item-data 'FLIEF' ls_oci_item-vendor.

* fill leading zeros.
        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
          EXPORTING
            input  = ls_cat_item-data-flief
          IMPORTING
            output = ls_cat_item-data-flief.

      ENDIF.
      map ls_cat_item-data 'KONNR' ls_oci_item-contract.
      map ls_cat_item-data 'KTPNR' ls_oci_item-contract_item.
      map ls_cat_item-data 'INFNR' ls_oci_item-purchinfrec.
      map ls_cat_item-data 'EKORG' ls_oci_item-purchorg.

      " Ehp5 Catalog changes, the contract reference should be done only if the contract was uploaded
      " from the same system or belongs to a central contract that has been distributed to the current system
      IF cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.
        IF ls_cat_item-data-pstyp EQ cl_mmpur_constants=>pstyp_9. "1768759
          ls_proposed_item-data-packno = lv_packno.
          ls_cat_item-data-packno      = lv_packno.
        ENDIF.
        IF lr_cl_mmbsi_cc_conv IS INITIAL.
          lr_cl_mmbsi_cc_conv = cl_mmbsi_cc_conv=>get_instance( ).
        ENDIF.

        IF ls_oci_item-sld_sys_name <> lv_logical_system_name.

          CLEAR ls_cat_item-data-konnr.
          CLEAR ls_cat_item-data-ktpnr.

          lv_contract_item = ls_oci_item-contract_item.

          CALL METHOD lr_cl_mmbsi_cc_conv->check_is_srm_contract
            EXPORTING
              iv_contract_id      = ls_oci_item-contract
              iv_contract_item_id = lv_contract_item
            IMPORTING
              ev_srm_flag         = lv_srm_flag
              ev_srm_contract_id  = lv_srm_contract_id.

          IF lv_srm_flag EQ abap_true.

            map ls_cat_item-data 'SRM_CONTRACT_ID'  ls_oci_item-contract.
            map ls_cat_item-data 'SRM_CONTRACT_ITM' ls_oci_item-contract_item.

          ENDIF.

        ELSE.

          IF ls_oci_item-item_type NE 'R'.

            CLEAR ls_cat_item-data-konnr.
            CLEAR ls_cat_item-data-ktpnr.

            lv_srvmapkey = ls_oci_item-contract_item.

            CALL METHOD lr_cl_mmbsi_cc_conv->get_erp_cont_item_id
              EXPORTING
                iv_erp_contract_id      = ls_oci_item-contract
                iv_srvmapkey            = lv_srvmapkey
              IMPORTING
                ev_erp_contract_item_id = lv_erp_contract_item.

            map ls_cat_item-data 'KONNR' ls_oci_item-contract.
            map ls_cat_item-data 'KTPNR' ls_oci_item-contract_item.

          ENDIF.

        ENDIF.

      ENDIF.

*     extra field mapping based on BAdI
      LOOP AT lt_map_fields INTO ls_map_fields.
        TRANSLATE ls_map_fields TO UPPER CASE.           "#EC TRANSLANG
        CASE ls_map_fields-item_field.
          WHEN 'WERKS'. ls_map_fields-item_field = 'NAME1'.
          WHEN 'RESWK'. ls_map_fields-item_field = 'RESWK_BEZ'.
          WHEN 'LGORT'. ls_map_fields-item_field = 'LGOBE'.
          WHEN 'MATKL'. ls_map_fields-item_field = 'WGBEZ'.
          WHEN 'PSTYP'. ls_map_fields-item_field = 'EPSTP'.
          WHEN 'RESLO'. ls_map_fields-item_field = 'RESLO_BEZ'.
          WHEN 'NETPR'. CONTINUE.
        ENDCASE.
        IF cl_ops_switch_check=>mm_sfws_cat_int( ) EQ abap_true.
          CASE ls_map_fields-catalog_field.
            WHEN 'CONTRACT'. CONTINUE.
            WHEN 'CONTRACT_ITEM'. CONTINUE.
          ENDCASE.
        ENDIF.
        ASSIGN COMPONENT ls_map_fields-catalog_field
               OF STRUCTURE ls_oci_item TO <source>.
        CHECK sy-subrc IS INITIAL.
        LOOP AT l_item_descr->components ASSIGNING <mapping>.
          ASSIGN COMPONENT <mapping>-name
                 OF STRUCTURE ls_cat_item TO <s_target>.
          CHECK sy-subrc IS INITIAL.
          ASSIGN COMPONENT ls_map_fields-item_field
                 OF STRUCTURE <s_target> TO <target>.
          CHECK sy-subrc IS INITIAL.
          TRY.
              CALL FUNCTION 'ME_MAP_CHAR_TO_PACK'
                EXPORTING
                  im_pack = <target>
                CHANGING
                  ch_char = <source>
                EXCEPTIONS
                  OTHERS  = 1.
              map <s_target> ls_map_fields-item_field <source>.
            CATCH cx_sy_conversion_error cx_sy_arithmetic_error.
*                 Fehler bei Datenübernahme von &1 aus dem Katalog
*                 in das Feld &2
              MESSAGE i765(me)
                WITH <source> ls_map_fields-item_field.
              l_map_error = mmpur_yes.
          ENDTRY.
        ENDLOOP.
      ENDLOOP.

*     text
      is_input_allowed 'ITEXT'.
      IF sy-subrc IS INITIAL.
        LOOP AT lt_oci_longtext INTO  ls_oci_longtext
                                WHERE line EQ ls_oci_item-line.
          ls_textline-tdobject  = 'EBAN'.
          ls_textline-tdid      = l_tdid.
          ls_textline-tdformat  = ls_oci_longtext-text_form.
          ls_textline-tdline    = ls_oci_longtext-text_line.
          APPEND ls_textline TO ls_cat_item-text.
        ENDLOOP.
      ENDIF.

      IF l_new_item EQ mmpur_no.
        MODIFY im_item_table FROM ls_cat_item INDEX l_tabix.
      ELSE.
        APPEND ls_cat_item TO im_item_table.

      ENDIF.
      CLEAR ls_cat_item.
    ENDLOOP.


    IF l_map_error EQ mmpur_yes.
      RAISE map_error.
    ENDIF.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""$"$\SE:(2) Class LCL_REQ_ITEM_GRID, Method READ_FROM_CATALOG, End                                                                                            A
*$*$-Start: (2)---------------------------------------------------------------------------------$*$*
ENHANCEMENT 1  Z_MAP_OCI_TO_ITEM.    "active version

*   map product group to MATKL

    LOOP AT LT_OCI_ITEM INTO LS_OCI_ITEM.
      L_TABIX = SY-TABIX.
      READ TABLE IM_ITEM_TABLE INDEX L_TABIX INTO LS_CAT_ITEM.

      IS_INPUT_ALLOWED 'MATKL'.
      IF SY-SUBRC IS INITIAL.
        MAP LS_CAT_ITEM-DATA 'MATKL' LS_OCI_ITEM-MATGROUP.
      ENDIF.

      MODIFY IM_ITEM_TABLE FROM LS_CAT_ITEM INDEX L_TABIX.
    ENDLOOP.

ENDENHANCEMENT.
*$*$-End:   (2)---------------------------------------------------------------------------------$*$*
  ENDMETHOD.                    "read_from_catalog

  METHOD catalog_texts.

    DATA: ls_texts       TYPE mmpur_textlines,
          lr_text        TYPE REF TO if_longtexts_mm,
          l_type         TYPE mmpur_t_texttypes,
          l_badi         TYPE REF TO me_catalog_interface.

    FIELD-SYMBOLS: <item> TYPE catalog_text_type.

*- text handling ------------------------------------------------------*
    LOOP AT my_catalog_texts ASSIGNING <item>.
      mmpur_dynamic_cast lr_text <item>-objref.
      IF lr_text IS BOUND.
*       get all available text types
        <item>-objref->if_longtexts_mm~get_types(
                           IMPORTING ex_texttypes = l_type ).
        IF NOT l_type[] IS INITIAL.
          CLEAR ls_texts.
          GET BADI l_badi.
          CALL BADI l_badi->determine_text_id
            EXPORTING
              im_bstyp = 'B'
            IMPORTING
              ex_tdid  = ls_texts-tdid.
          IF ls_texts-tdid IS INITIAL.
            LOOP AT <item>-lines INTO ls_texts.
              EXIT.
            ENDLOOP.
          ENDIF.
          CALL METHOD lr_text->set_text(
            EXPORTING
              im_tdid      = ls_texts-tdid
              im_textlines = <item>-lines ).
        ENDIF.
      ENDIF.
    ENDLOOP.
    REFRESH my_catalog_texts.

  ENDMETHOD.                    "catalog-texts

  METHOD serial_list.
    TYPES: BEGIN OF lty_documents,
             edokn TYPE edokn,
             edokp TYPE edokp,
             anzsn TYPE anzsn,
             matnr TYPE matnr,
             werks TYPE werks,
             etenr TYPE eeten,
             bstyp TYPE bstyp,
           END OF lty_documents.
    DATA: lt_models      TYPE mmpur_models,
          l_model        TYPE LINE OF mmpur_models,
          ls_documents   TYPE lty_documents,
          lt_documents   TYPE TABLE OF lty_documents,
          l_item         TYPE REF TO if_purchase_requisition_item,
          l_header       TYPE REF TO if_purchase_requisition,
          l_mereq_item   TYPE mereq_item,
          l_mereq_header TYPE mereq_header.

    BREAK-POINT ID mmpur_serialno.
    CHECK cl_ops_switch_check=>mm_sfws_serno( ) EQ cl_mmpur_constants=>yes.
    me->get_selection( IMPORTING ex_models = lt_models ).
    IF NOT lt_models IS INITIAL.
      REFRESH lt_documents.
      LOOP AT lt_models INTO l_model.
        mmpur_dynamic_cast l_item l_model-model.
        CHECK l_item IS BOUND.
        CALL METHOD l_item->get_data
          RECEIVING
            re_data = l_mereq_item.
        IF l_mereq_header-banfn IS INITIAL.
          CALL METHOD l_item->get_requisition
            RECEIVING
              re_requisition = l_header.
          CALL METHOD l_header->get_data
            RECEIVING
              re_data = l_mereq_header.
        ENDIF.
        ls_documents-edokn = l_mereq_header-banfn.
        ls_documents-edokp = l_mereq_item-bnfpo.
        ls_documents-anzsn = l_mereq_item-anzsn.
        ls_documents-matnr = l_mereq_item-matnr.
        ls_documents-werks = l_mereq_item-werks.
        ls_documents-bstyp = cl_mmpur_constants=>bstyp_b.
        APPEND ls_documents TO lt_documents.
      ENDLOOP.
      IF NOT lt_documents IS INITIAL.
        CALL FUNCTION 'MMPUR_LIST_SERNOS'
          EXPORTING
            im_documents = lt_documents.
      ENDIF.
      REFRESH lt_models.
      me->set_selection( EXPORTING im_models = lt_models
                                   im_deselect = cl_mmpur_constants=>yes ).
    ELSE.
      MESSAGE s103(06).
    ENDIF.
  ENDMETHOD.                    "serial_list

  METHOD execute_before_transport.

    DATA: l_fcode TYPE sy-ucomm VALUE 'MEREQFLUSH'.

    CALL METHOD super->execute_before_transport
      CHANGING
        im_fcode = im_fcode.

    CASE im_fcode.

      WHEN '&MEREQDETAIL' OR
           '&MEREQRELALL' OR
           '&MEREQRELPROP' OR
           '&MEREQALLPROP' OR
           '&SN_OVERVIEW' OR
           'MEDIDOCF'.         " EHP5 -> extended document flow
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = im_fcode ).

      WHEN '&MEREQDELETE'.
        CALL METHOD change_deletion_indicator( mmpur_yes ).
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEREQUNDELETE'.
        CALL METHOD change_deletion_indicator( mmpur_no ).
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEITPRP'.
        l_fcode = 'MEITPRP'.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEREQCOPY'.
        CALL METHOD copy_items.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEREQDUPLICATE'.
        CALL METHOD duplicate_item.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MESOURCEASSIGNALL'.
        CALL METHOD assign_source_of_supply.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEREQAVAIL'.
        CALL METHOD availability_check.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEREQDMS'.
        CALL METHOD linked_dms_documents.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

*DCM complete version in all selected items
      WHEN '&MEREQDCMALL'.
        CALL METHOD complete_version_all.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEREQMASS' OR
           '&MEREQMASSLINE'.

        DATA: l_gt TYPE REF TO lcl_mass_change,
          lt_cols TYPE lvc_t_col,
          ls_col  LIKE LINE OF lt_cols,
          l_view  TYPE REF TO cl_screen_view_mm,
          l_table_control TYPE REF TO cl_table_view_mm,
          lt_models TYPE mmpur_models,
          lt_all_models TYPE mmpur_models,
          l_model TYPE REF TO if_model_mm,
          l_metafield TYPE mmpur_metafield.

        CALL METHOD get_selection
          IMPORTING
            ex_models = lt_models.

        lt_all_models = if_multiple_model_holder_mm~get_models( ).

        CREATE OBJECT l_gt.

        IF im_fcode EQ '&MEREQMASSLINE'.

          CALL METHOD get_model_of_current_cell
            IMPORTING
              ex_model     = l_model
              ex_metafield = l_metafield.

          IF NOT l_model IS INITIAL AND
             NOT l_metafield IS INITIAL.

            DATA: l_index TYPE sy-tabix,
                  l_lines TYPE sy-tfill,
                  ls_mytable LIKE LINE OF my_table,
                  l_req_item TYPE REF TO if_purchase_requisition_item,
                  ls_dynp LIKE LINE OF my_dynpro_fields,
                  l_datatype(80) TYPE c.

            FIELD-SYMBOLS: <f1> TYPE any.

            l_req_item ?= l_model.

            READ TABLE my_table INTO ls_mytable
                  WITH KEY objref = l_req_item.

            IF sy-subrc IS INITIAL.

              READ TABLE my_dynpro_fields INTO ls_dynp
                  WITH KEY metafield = l_metafield.

              IF sy-subrc IS INITIAL.

                ASSIGN COMPONENT ls_dynp-fieldname
                    OF STRUCTURE ls_mytable TO <f1>.

                IF sy-subrc IS INITIAL.

                  CONCATENATE
                    'MEGUI_MASSCH_ALLOWED_FIELDS-'
                    ls_dynp-fieldname INTO l_datatype.

                  CALL METHOD l_gt->store_default
                    EXPORTING
                      im_datatype = l_datatype
                      im_value    = <f1>.

                  ls_col-fieldname = ls_dynp-fieldname.
                  INSERT ls_col INTO TABLE lt_cols.

                ENDIF.

              ENDIF.

            ENDIF.

          ENDIF.

        ENDIF.
*        CALL METHOD get_selected_columns
*                         IMPORTING ex_row_col_table = lt_cols.

        CALL METHOD l_gt->start
          EXPORTING
            im_structname    = 'MEREQ_ITEM'
            im_selected_cols = lt_cols
            im_selected_objs = lt_models
            im_all_objs      = lt_all_models.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

      WHEN '&MEREQCATALOG'.
        CALL METHOD get_catalog.
        CALL METHOD cl_gui_cfw=>set_new_ok_code( new_code = 'MEREQCATALOG' ). "n _1308889

      WHEN '&MEREQEXTMATSEARCH'.
        CALL METHOD call_ext_mat_search( ).
        CALL METHOD cl_gui_cfw=>set_new_ok_code( l_fcode ).


    ENDCASE.

  ENDMETHOD.                    "execute_before_transport

  METHOD get_catalog.

    DATA: lt_cat_item  TYPE item_catalog_table_type,
          ls_cat_item  TYPE item_catalog_data_type,
          lines        TYPE i,
          ls_models    TYPE mmpur_model_type,
          lt_models    TYPE mmpur_models,
          l_item_model TYPE mereq3211grid,
          l_null       TYPE REF TO if_purchase_requisition_item.

*- find 'existend' and selected items --------------------------------*
    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

*- generate input file over all 'exist' items ... --------------------*
    LOOP AT lt_models INTO ls_models.
      ls_cat_item-data-objref ?= ls_models-model.
*     ... from item overview dynpro
      READ TABLE my_table WITH KEY objref = ls_cat_item-data-objref
                               INTO l_item_model.
      MOVE-CORRESPONDING l_item_model TO ls_cat_item-data.
      APPEND ls_cat_item TO lt_cat_item.
      CLEAR ls_cat_item.
    ENDLOOP.

*- append a proposed item for new items from catalog -----------------*
    IF NOT my_proposer IS INITIAL.
      CALL METHOD conversions_output
        EXPORTING
          im_item = my_proposed_item
          im_obj  = l_null
        IMPORTING
          ex_data = ls_cat_item-data.
      APPEND ls_cat_item TO lt_cat_item.
      CLEAR ls_cat_item.
    ENDIF.

*- get data from catalog ---------------------------------------------*
    CALL METHOD read_from_catalog
      CHANGING
        im_item_table  = lt_cat_item
      EXCEPTIONS
        map_error      = 1
        illegal_call   = 2
        no_data_import = 3.

*- set catalog items to model ----------------------------------------*
    IF sy-subrc LE 1.
      DESCRIBE TABLE lt_cat_item LINES lines.
    ENDIF.
    CHECK NOT lines IS INITIAL.
    CALL METHOD transport_from_catalog
      CHANGING
        im_item_table = lt_cat_item.

*- reset selected items ----------------------------------------------*
    REFRESH lt_models.
    CALL METHOD set_selection
      EXPORTING
        im_models   = lt_models
        im_deselect = cl_mmpur_constants=>yes.

  ENDMETHOD.                    "get_catalog

  METHOD call_ext_mat_search.
    DATA:ls_search_param TYPE wsd_ms_initial_params_sty,
         lt_matlist      TYPE wsd_ms_return_tty,
         ls_material_data  TYPE wsd_ms_return_sty,
         ls_header_data  TYPE mereq_header,                 "1629594
         ls_item_data    TYPE mereq3211grid,
         ls_werks        TYPE werks_d,
         lref_header     TYPE REF TO if_purchase_requisition,
         l_null          TYPE REF TO if_purchase_requisition_item,
         ls_basic_cfg    TYPE wsdt_basic_cfg.

    FIELD-SYMBOLS: <a_row> TYPE mereq3211grid.

    mmpur_dynamic_cast lref_header my_model.

    CHECK NOT lref_header IS INITIAL.

    IF lref_header->is_valid( ) IS INITIAL.
      EXIT.
    ENDIF.

    ls_basic_cfg = cl_wsd_config=>read_mat_basic_config( i_app_name = cl_wsd_constants=>co_appl_purchase_order ).

    IF ls_basic_cfg-so_active IS INITIAL.
      RETURN.
    ENDIF.

    ls_header_data = lref_header->get_data( ).              "#EC *

* determine plant from personal settings or user paraneter
    MOVE-CORRESPONDING my_proposed_item TO ls_item_data.

    IF ls_item_data-werks IS INITIAL.
      CALL FUNCTION 'WSD_READ_PLANT_PARAM'
        IMPORTING
          e_werks = ls_werks.
      IF ls_werks IS INITIAL.

        CALL FUNCTION 'WSD_SELECT_OWN_PLANT'                      "1629594
          IMPORTING
            e_werks = ls_werks.
      ENDIF.
    ELSE.
      ls_werks = ls_item_data-werks.
    ENDIF.

    IF ls_werks IS NOT INITIAL.
      ls_search_param-app_name = cl_wsd_constants=>co_appl_purchase_order.
      ls_search_param-werks = ls_werks.
      CALL FUNCTION 'WSD_MATERIAL_SEARCH' DESTINATION 'NONE'
        EXPORTING
          is_params             = ls_search_param
        IMPORTING
          et_return             = lt_matlist
        EXCEPTIONS
          communication_failure = 1
          system_failure        = 2.

      LOOP AT lt_matlist INTO ls_material_data.
        CALL METHOD conversions_output
          EXPORTING
            im_item = my_proposed_item
            im_obj  = l_null
          IMPORTING
            ex_data = ls_item_data.
        ls_item_data-matnr = ls_material_data-matnr.
        ls_item_data-werks = ls_material_data-werks.
        ls_item_data-menge = ls_material_data-kwmeng.
        ls_item_data-meins = ls_material_data-vrkme.
        READ TABLE my_table ASSIGNING <a_row> WITH KEY objref = l_null alv_data_changed = mmpur_no.
        IF <a_row> IS ASSIGNED.
          <a_row> = ls_item_data.
          <a_row>-alv_data_changed = mmpur_yes.
          CLEAR ls_item_data.
          CALL METHOD conversions_output
            EXPORTING
              im_item = my_proposed_item
              im_obj  = l_null
            IMPORTING
              ex_data = ls_item_data.
          ls_item_data-mereqitemdummy = 'X'.
          APPEND ls_item_data TO my_table.
        ENDIF.
      ENDLOOP.
      CALL FUNCTION 'MARC_ARRAY_READ'
        EXPORTING
          kzrfb  = 'X'
        EXCEPTIONS
          OTHERS = 1.
      IF sy-subrc <> 0.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "call_ext_mat_search

  METHOD handle_context_menu_request.
    DATA: li_sel_col TYPE i,           "selected column
          lt_fieldselection TYPE ttyp_fieldselection_mm,    "635554
          l_fs_entry  LIKE LINE OF lt_fieldselection,
          l_metafield TYPE mmpur_metafield,
          l_disabled.     "X -> only display

    CALL METHOD super->handle_context_menu_request
      EXPORTING
        e_object = e_object.

* Build fs table: mmmfd_item_copy, mmmfd_delete_item, ...     HW 635554
    CLEAR l_fs_entry.
    l_fs_entry-metafield = mmmfd_item_copy.
    INSERT l_fs_entry INTO TABLE lt_fieldselection.

    CALL METHOD my_req->if_fieldselection_mm~fs_get
      CHANGING
        ch_fieldselection = lt_fieldselection.

* § 3.Query which column was selected.
    CALL METHOD my_grid->get_current_cell
      IMPORTING
        e_col = li_sel_col.
    CALL METHOD cl_gui_cfw=>flush.
    IF sy-subrc NE 0.
* add your handling, for example
    ENDIF.

    CALL METHOD e_object->add_separator.
    CALL METHOD e_object->add_function
      EXPORTING
        fcode = '&MEREQDETAIL'
        text  = text-r08.

*DCM exclude functions for buyer approval
    DATA: l_document TYPE mepo_document.
    CALL METHOD my_req->get_transaction_state
      IMPORTING
        ex_document = l_document.
    IF l_document-initiator-initiator NE mmpur_initiator_ba.

* Determine field status for mmmfd_item_copy                  HW 635554
      CLEAR: l_fs_entry, l_disabled.
      READ TABLE lt_fieldselection WITH KEY metafield = mmmfd_item_copy
                                   INTO l_fs_entry.
      IF l_fs_entry-fieldstatus NE '-'.
        IF l_fs_entry-fieldstatus EQ '*'.
          l_disabled = mmpur_yes.
        ENDIF.
        CALL METHOD e_object->add_separator.
        CALL METHOD e_object->add_function
          EXPORTING
            fcode    = '&MEREQDUPLICATE'
            text     = text-r14
            disabled = l_disabled.                          "635554
      ENDIF.
    ENDIF.

*    CALL METHOD e_object->add_separator.
*    CALL METHOD e_object->add_function
*         EXPORTING fcode = '&MEREQMASSLINE'
*                   text  = text-r24.
    CALL METHOD cl_gui_cfw=>flush.

  ENDMETHOD.                    "handle_context_menu_request

  METHOD handle_f4.

    DATA: l_epstp  TYPE mereq3211grid-epstp,
          l_bsart  TYPE mereq3211grid-bsart,                "439732
          l_werks  TYPE mereq3211grid-werks,
          l_elpei  TYPE mereq3211grid-elpei,
          l_eeind  TYPE mereq3211grid-eeind,
          l_matnr  TYPE mereq3211grid-matnr,
          l_new_unit TYPE mereq3211grid-meins,
          l_bwtar  TYPE mereq3211grid-bwtar,                "862255
          l_mode   TYPE char1,
          l_ch     TYPE mmpur_bool,
          ls_modi  TYPE lvc_s_modi,
          ls_wa    LIKE LINE OF my_table.

    FIELD-SYMBOLS: <fs_t_modi> TYPE lvc_t_modi,
                   <fs_wa>     LIKE ls_wa.

    l_ch = is_field_changeable( im_fieldname = e_fieldname
                                im_row_no    = es_row_no ).

    IF l_ch EQ mmpur_yes.
      l_mode = 'U'.
    ELSE.
      l_mode = 'D'.
    ENDIF.

    er_event_data->m_event_handled = 'X'.

    CASE e_fieldname.
      WHEN 'EPSTP'.                                         "439732
        READ TABLE my_table ASSIGNING <fs_wa> INDEX es_row_no-row_id.
        IF sy-subrc IS INITIAL.
          l_bsart = <fs_wa>-bsart.
        ELSE.
          CLEAR l_bsart.
        ENDIF.
        CALL FUNCTION 'HELP_VALUES_EPSTP'
          EXPORTING
            program       = prog
            dynnr         = dynpro
            fieldname     = 'MEREQ3211GRID-EPSTP'
            bsart         = l_bsart
            bstyp         = bstyp-banf
            mode          = l_mode
          IMPORTING
            epstp         = l_epstp
          EXCEPTIONS
            error_message = 1
            OTHERS        = 2.

        IF sy-subrc IS INITIAL AND l_ch EQ mmpur_yes.
          ls_modi-value     = l_epstp.
          ls_modi-row_id    = es_row_no-row_id.
          ls_modi-fieldname = e_fieldname.
        ENDIF.

* plant
      WHEN 'NAME1' OR 'RESWK_BEZ'. "Conversion of Supplying Sloc and Reswk
        CALL FUNCTION 'HELP_VALUES_WERKS'
          EXPORTING
            i_program     = prog
            i_dynnr       = dynpro
          IMPORTING
            e_werks       = l_werks
          EXCEPTIONS
            error_message = 1
            OTHERS        = 2.

        IF sy-subrc IS INITIAL AND l_ch EQ mmpur_yes.
          ls_modi-value  = l_werks.
        ENDIF.

* delivery date category
      WHEN 'ELPEI'.
        CALL FUNCTION 'ME_VALUES_TPRG'
          IMPORTING
            e_lpein = l_elpei.

        IF l_ch EQ mmpur_yes.
          ls_modi-value  = l_elpei.
        ENDIF.

* delivery date
      WHEN 'EEIND'.

        READ TABLE my_table ASSIGNING <fs_wa> INDEX es_row_no-row_id.

        IF sy-subrc IS INITIAL.

          CALL METHOD f4_for_date
            EXPORTING
              im_display = l_mode
              im_elpei   = <fs_wa>-elpei
            IMPORTING
              ex_elpei   = l_elpei
              ex_eeind   = l_eeind
            EXCEPTIONS
              failed     = 1.

          IF sy-subrc IS INITIAL AND l_ch EQ mmpur_yes.
            ASSIGN er_event_data->m_data->* TO <fs_t_modi>.

            ls_modi-row_id    = es_row_no-row_id.
            ls_modi-fieldname = 'EEIND'.
            ls_modi-value  = l_eeind.
            APPEND ls_modi TO <fs_t_modi>.
            <fs_wa>-eeind = l_eeind.
            <fs_wa>-elpei = l_elpei.

            ls_modi-row_id    = es_row_no-row_id.
            ls_modi-fieldname = 'ELPEI'.
            ls_modi-value  = l_elpei.
            APPEND ls_modi TO <fs_t_modi>.

            CLEAR ls_modi.
          ENDIF.
        ENDIF.

* valuation type                                        note 862255
      WHEN 'BWTAR'.

        READ TABLE my_table ASSIGNING <fs_wa> INDEX es_row_no-row_id.
        IF sy-subrc IS INITIAL.
          l_matnr = <fs_wa>-matnr.
          l_werks = <fs_wa>-werks.
        ELSE.
          CLEAR: l_matnr,
                 l_werks.
        ENDIF.
        CALL FUNCTION 'HELP_VALUES_BWTAR'
          EXPORTING
            im_matnr    = l_matnr
            im_werks    = l_werks
            im_mode     = l_mode
          IMPORTING
            ex_bwtar    = l_bwtar
          EXCEPTIONS
            wrong_input = 1
            OTHERS      = 2.
        IF sy-subrc <> 0.
*          message id sy-msgid type 'S' number sy-msgno
*                  with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ELSEIF l_bwtar NE space AND
               l_ch EQ mmpur_yes.
          ls_modi-value  = l_bwtar.
        ENDIF.

* order unit                                            note 872955
      WHEN 'MEINS'.

        READ TABLE my_table ASSIGNING <fs_wa> INDEX es_row_no-row_id.
        IF sy-subrc IS INITIAL.
          l_matnr = <fs_wa>-matnr.
        ELSE.
          CLEAR l_matnr.
        ENDIF.
        IF l_ch EQ mmpur_yes.
          CLEAR l_mode.
        ELSE.
          l_mode = 'X'.
        ENDIF.
        CALL FUNCTION 'HELP_VALUES_MEINS_ALV'
          EXPORTING
            i_matnr = l_matnr
            i_mode  = l_mode
          IMPORTING
            e_unit  = l_new_unit
          EXCEPTIONS
            OTHERS  = 1.
        IF sy-subrc IS INITIAL AND l_ch EQ mmpur_yes.
          ls_modi-value  = l_new_unit.
        ENDIF.

      WHEN OTHERS.
        CLEAR er_event_data->m_event_handled.

    ENDCASE.

    IF NOT ls_modi IS INITIAL.

      ASSIGN er_event_data->m_data->* TO <fs_t_modi>.

      ls_modi-row_id    = es_row_no-row_id.
      ls_modi-fieldname = e_fieldname.
      APPEND ls_modi TO <fs_t_modi>.
    ENDIF.

  ENDMETHOD.                                                "handle_f4

  METHOD get_fields_for_f4.

    DATA: ls_f4 LIKE LINE OF re_t_f4,
          ls_fcat LIKE LINE OF gt_fieldcatalog.

    re_t_f4 = super->get_fields_for_f4( ).

    DEFINE lmac_upd_then_ins.

      ls_f4-fieldname  = &1.
      ls_f4-register   = 'X'.
      ls_f4-getbefore  = &2.
      ls_fcat-f4availabl = 'X'.

      modify gt_fieldcatalog from ls_fcat transporting f4availabl
        where fieldname eq ls_f4-fieldname.

      if sy-subrc is initial.

        modify re_t_f4 from ls_f4
            transporting register chngeafter getbefore
                 where fieldname eq ls_f4-fieldname.

        if not sy-subrc is initial.
          insert ls_f4 into table re_t_f4.
        endif.
      endif.
    END-OF-DEFINITION.

    lmac_upd_then_ins 'EPSTP' ''.
    lmac_upd_then_ins 'NAME1' ''.
*   Conversion of Supplying Sloc and Reswk
    lmac_upd_then_ins 'RESWK_BEZ' ''.
    lmac_upd_then_ins 'ELPEI' ''.
    lmac_upd_then_ins 'EEIND' 'X'.
    lmac_upd_then_ins 'BWTAR' ''.                           "862255
    lmac_upd_then_ins 'MEINS' ''.                           "872955
*    lmac_upd_then_Ins 'CHARG' ''.

  ENDMETHOD.                    "get_fields_for_f4

  METHOD f4_for_date.

    DATA: l_eindt TYPE workflds-gkday,
          ls_tprg TYPE tprg,
          l_display  TYPE char1.

    IF im_display EQ 'D'.
      l_display = 'X'.
    ENDIF.

*- Interne Darstellung vom Datumstyp besorgen -------------------------*
    IF im_elpei IS INITIAL.
      ls_tprg-prgrs = '1'.
    ELSE.
      SELECT SINGLE * FROM tprg INTO ls_tprg
                                WHERE spras EQ sy-langu
                                  AND prgbz EQ im_elpei.
      IF sy-subrc NE 0.
*  message e346(v1) with e_lpein.
        MESSAGE s346(v1) WITH im_elpei.
        RAISE failed.
      ENDIF.
    ENDIF.

*- F4-Hilfe aufrufen --------------------------------------------------*
    CALL FUNCTION 'F4_DATE'
      EXPORTING
        date_for_first_month = sy-datlo
        display              = l_display
      IMPORTING
        select_date          = l_eindt
      EXCEPTIONS
        OTHERS               = 8.
    IF sy-subrc NE 0.
*  message e845(06).
      MESSAGE s845(06).
      RAISE failed.
    ENDIF.

*- Datum in externe Darstellung konvertieren --------------------------*
    IF NOT l_eindt IS INITIAL.
      CALL FUNCTION 'PERIOD_AND_DATE_CONVERT_OUTPUT'
        EXPORTING
          internal_date   = l_eindt
          internal_period = ls_tprg-prgrs
        IMPORTING
          external_date   = ex_eeind
          external_period = ex_elpei.
    ENDIF.

  ENDMETHOD.                    "f4_for_date

  METHOD copy_items.

    DATA: lt_models TYPE mmpur_models,
          ls_models LIKE LINE OF lt_models,
          ls_req_items LIKE LINE OF my_copied_items.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      mmpur_dynamic_cast ls_req_items-item ls_models-model.

      CHECK NOT ls_req_items-item IS INITIAL.

      me->sync_item( ls_req_items-item ).                   "1109865

      ls_req_items-item =
        my_req->create_item( im_item = ls_req_items-item ).

      IF NOT ls_req_items-item IS INITIAL.
        INSERT ls_req_items INTO TABLE my_copied_items.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "copy_items

  METHOD duplicate_item.

    DATA: l_model TYPE REF TO if_model_mm,
          ls_req_items LIKE LINE OF my_copied_items.

    CALL METHOD get_model_of_current_cell
      IMPORTING
        ex_model = l_model.

    mmpur_dynamic_cast ls_req_items-item l_model.

    CHECK NOT ls_req_items-item IS INITIAL.

    me->sync_item( ls_req_items-item ).                     "1109865

    ls_req_items-item =
      my_req->create_item( im_item = ls_req_items-item ).

    IF NOT ls_req_items-item IS INITIAL.
      INSERT ls_req_items INTO TABLE my_copied_items.
    ENDIF.

  ENDMETHOD.                    "duplicate_item

  METHOD sync_item.                                         "1109865

    DATA: l_old_data LIKE LINE OF my_table.
    FIELD-SYMBOLS: <a_row> LIKE LINE OF my_table.

    CHECK NOT im_req_item IS INITIAL.
    READ TABLE my_table ASSIGNING <a_row> WITH KEY objref = im_req_item.
    CHECK sy-subrc IS INITIAL.
    CHECK <a_row>-alv_data_changed = mmpur_yes.

    READ TABLE my_table_old INTO l_old_data
        WITH KEY objref = im_req_item  BINARY SEARCH.
    CHECK sy-subrc IS INITIAL.
    me->conversions_input( EXPORTING im_data_old = l_old_data
                           CHANGING  ch_data     = <a_row> ).
    me->notify_data_changed( im_req_item ).
    me->transport_to_model( im_req_item ).

  ENDMETHOD.                    "sync_item

  METHOD availability_check.
    DATA: lt_models      TYPE mmpur_models,
          ls_models      LIKE LINE OF lt_models,
          ls_req_items   LIKE LINE OF my_copied_items.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      mmpur_dynamic_cast ls_req_items-item ls_models-model.

      CHECK NOT ls_req_items-item IS INITIAL.

      CALL METHOD ls_req_items-item->availability_check
        EXPORTING
          im_mode = if_purchase_requisition_item=>c_acmod_explicit.

    ENDLOOP.

  ENDMETHOD.                    "availability_check

  METHOD linked_dms_documents.
    DATA: lt_models      TYPE mmpur_models,
          ls_models      LIKE LINE OF lt_models,
          l_dms_cnt      TYPE REF TO if_command_mm,
          l_fcode        TYPE sy-ucomm VALUE 'DUMMY'.

    CREATE OBJECT l_dms_cnt
      TYPE
      lcl_dms_controller.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      CALL METHOD l_dms_cnt->execute
        EXPORTING
          im_model = ls_models-model
        CHANGING
          im_fcode = l_fcode.
*DCM trigger new version test
      CALL METHOD notify_data_changed( ls_models-model ).

      IF l_fcode IS INITIAL.
        EXIT.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "linked_dms_documents

  METHOD change_deletion_indicator.
    DATA: lt_models      TYPE mmpur_models,
          ls_models      LIKE LINE OF lt_models,
          ls_req_items   LIKE LINE OF my_copied_items,
          ls_mereqitem   TYPE mereq_item,
          l_answer       TYPE c.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    IF NOT lt_models[] IS INITIAL AND
       im_delete EQ mmpur_yes.

      CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
        EXPORTING
          defaultoption = 'N'
          diagnosetext1 = text-312
          diagnosetext2 = text-313
          diagnosetext3 = text-314
          textline1     = text-316
          titel         = text-315
        IMPORTING
          answer        = l_answer.

      IF l_answer NE 'J'.
        EXIT.
      ENDIF.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      mmpur_dynamic_cast ls_req_items-item ls_models-model.

      CHECK NOT ls_req_items-item IS INITIAL.

      ls_mereqitem = ls_req_items-item->get_data( ).

      IF im_delete EQ mmpur_yes AND
         ls_mereqitem-loekz IS INITIAL.

        ls_mereqitem-loekz = 'X'.
        CALL METHOD ls_req_items-item->set_data( ls_mereqitem ).
        INSERT ls_req_items INTO TABLE my_copied_items.

      ELSEIF im_delete EQ mmpur_no AND
         NOT ls_mereqitem-loekz IS INITIAL.

        CLEAR ls_mereqitem-loekz.
        CALL METHOD ls_req_items-item->set_data( ls_mereqitem ).
        INSERT ls_req_items INTO TABLE my_copied_items.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "change_deletion_indicator

  METHOD drag_drop_init.

    CALL METHOD super->drag_drop_init.

    IF NOT my_drag_drop IS INITIAL AND
       NOT my_grid      IS INITIAL.

      CALL METHOD my_drag_drop->get
        EXPORTING
          flavor    = mmpur_flavor_req
        EXCEPTIONS
          not_found = 1
          OTHERS    = 2.

      IF NOT sy-subrc IS INITIAL.

        CALL METHOD my_drag_drop->add
          EXPORTING
            flavor     = mmpur_flavor_req
            dragsrc    = 'X'
            droptarget = 'X'
            effect     = cl_dragdrop=>copy.

        SET HANDLER handle_on_drag FOR my_grid ACTIVATION space.
        SET HANDLER handle_on_drop FOR my_grid ACTIVATION space.
        SET HANDLER handle_on_drag FOR my_grid.
        SET HANDLER handle_on_drop FOR my_grid.

      ENDIF.
    ENDIF.

  ENDMETHOD.                    "drag_drop_init

  METHOD handle_on_drop.

    DATA: l_tablemodel TYPE REF TO cl_table_model_mm,
          l_fcode      TYPE sy-ucomm VALUE 'COPYREQS'.

    mmpur_dynamic_cast l_tablemodel e_dragdropobj->object.

    CHECK NOT l_tablemodel IS INITIAL AND
          my_copied_items[] IS INITIAL.

    me->create_reqitem_with_reference( l_tablemodel ).
* note 999402: always sync control framework
    cl_gui_cfw=>set_new_ok_code( new_code = l_fcode ).

  ENDMETHOD.                    "handle_on_drop

  METHOD handle_data_dropped.
    CHECK my_copied_items[] IS INITIAL.

    CALL METHOD create_reqitem_with_reference( ex_table_model ).
  ENDMETHOD.                    "handle_data_dropped

  METHOD get_dragdrop_controller.
    re_cnt = my_dragdrop_controller.
  ENDMETHOD.                    "get_dragdrop_controller

  METHOD create_reqitem_with_reference.

    DATA: ltr_selection       TYPE REF TO data,
          lt_fieldcatalog     TYPE lvc_t_fcat,
          ls_fieldcatalog     TYPE lvc_s_fcat,
          l_belegnr           TYPE lvc_fname,
          l_belegpos          TYPE lvc_fname,
          lt_docs             TYPE mepo_documents,
          l_mepo_doc          TYPE mepo_document,
          l_option            TYPE mepo_initiator_option,
          lt_req_items        TYPE mmpur_requisition_items,
          ls_req_items        LIKE LINE OF my_copied_items. "743727

    FIELD-SYMBOLS: <table> TYPE table,
                   <wa>    TYPE any,
                   <docnr>    TYPE any,
                   <docpos>   TYPE any.

    CHECK NOT im_table_model IS INITIAL AND
          NOT my_req IS INITIAL.

    CALL METHOD im_table_model->get_table
      IMPORTING
        ex_tableref     = ltr_selection
        ex_fieldcatalog = lt_fieldcatalog[].

    CHECK NOT ltr_selection IS INITIAL.

    ASSIGN ltr_selection->* TO <table>.

    CHECK sy-subrc EQ 0.

    LOOP AT lt_fieldcatalog INTO ls_fieldcatalog
          WHERE key EQ 'X'.

      CASE ls_fieldcatalog-domname.
*        WHEN 'BSTNR' OR 'EBELN'.   not for 4.6c
*          l_document-doc_type = 'F'.
*          EXIT.
        WHEN 'BANFN'.
          l_belegnr = ls_fieldcatalog-fieldname.
        WHEN 'BNFPO'.
          l_belegpos = ls_fieldcatalog-fieldname.
      ENDCASE.
    ENDLOOP.

    CHECK NOT l_belegnr IS INITIAL AND
          NOT l_belegpos IS INITIAL.

    LOOP AT <table> ASSIGNING <wa>.

      ASSIGN COMPONENT l_belegnr  OF STRUCTURE <wa> TO <docnr>.
      IF sy-subrc NE 0.
        EXIT.
      ENDIF.
      ASSIGN COMPONENT l_belegpos OF STRUCTURE <wa> TO <docpos>.
      IF sy-subrc NE 0.
        EXIT.
      ENDIF.

      CLEAR l_mepo_doc.
      l_mepo_doc-process  = mmpur_req_process.
      l_mepo_doc-trtyp    = anz.
      l_mepo_doc-doc_type = bstyp-banf.
      l_mepo_doc-doc_key  = <docnr>.

      CLEAR l_option.
      l_option-property = mmpur_requested_item.
      l_option-value    = <docpos>.
      INSERT l_option INTO TABLE l_mepo_doc-initiator-options.

      INSERT l_mepo_doc INTO TABLE lt_docs.

    ENDLOOP.

    CHECK NOT lt_docs[] IS INITIAL.

    lt_req_items = my_req->create_items_by_key( lt_docs ).
    APPEND LINES OF lt_req_items TO my_copied_items.
    LOOP AT my_copied_items INTO ls_req_items.              "743727
      CALL METHOD notify_data_changed( ls_req_items-item ). "743727
    ENDLOOP.                                                "743727
    REFRESH my_copied_items.                                "743727

  ENDMETHOD.                    "create_reqitem_with_reference

  METHOD copy_with_reference.

    DATA: lt_req_items        TYPE mmpur_requisition_items,
          lt_docs             TYPE mepo_documents,
          l_mepo_doc          TYPE mepo_document,
          l_option            TYPE mepo_initiator_option.

    CHECK NOT im_banfn IS INITIAL.

    l_mepo_doc-doc_key = im_banfn.
    l_mepo_doc-process = mmpur_req_process.
    l_mepo_doc-trtyp = anz.
    l_mepo_doc-doc_type = bstyp-banf.

    IF NOT im_bnfpo IS INITIAL.
      l_option-property = mmpur_requested_item.
      l_option-value    = im_bnfpo.
      INSERT l_option INTO TABLE l_mepo_doc-initiator-options.
    ENDIF.

    INSERT l_mepo_doc INTO TABLE lt_docs.

    lt_req_items = my_req->create_items_by_key( lt_docs ).
    APPEND LINES OF lt_req_items TO re_items.

  ENDMETHOD.                    "copy_with_reference

  METHOD on_event_double_click.

    DATA: l_item   TYPE REF TO if_purchase_requisition_item.
    DATA: l_parent TYPE REF TO cl_screen_view_mm.
    DATA: l_name   TYPE string40.

    CHECK ex_view EQ me.
    CHECK NOT ex_model IS INITIAL.

    mmpur_dynamic_cast l_item ex_model.
    CHECK NOT l_item IS INITIAL.

    CASE ex_metafield.
      WHEN mmmfd_acctasscat.
        l_name = c_accountings.
      WHEN mmmfd_textflag.
        l_name = c_item_texts.
    ENDCASE.

    IF NOT l_name IS INITIAL.

      l_parent = me->parent_view.

      DO.
        IF l_parent->parent_view IS INITIAL.
          EXIT.
        ENDIF.

        l_parent = l_parent->parent_view.

      ENDDO.

      CALL METHOD l_parent->lookup
        EXPORTING
          im_name   = l_name
        IMPORTING
          ex_view   = l_parent
        EXCEPTIONS
          not_found = 1.

      IF sy-subrc EQ 0 AND NOT l_parent IS INITIAL.
        CALL METHOD l_parent->set_focus.
        CALL METHOD if_multiple_model_holder_mm~set_current_model( l_item ).
      ENDIF.

    ELSEIF ex_metafield EQ mmmfd_preq_item.
      CALL METHOD if_multiple_model_holder_mm~set_current_model( l_item ).

    ELSEIF ex_metafield EQ mmmfd_banpricon.
      CALL METHOD process_banpr( l_item ).

    ENDIF.


  ENDMETHOD.                    "on_event_double_click

  METHOD if_multiple_model_holder_mm~set_current_model.
    DATA: l_model TYPE REF TO if_purchase_requisition_item,
          ls_data LIKE LINE OF my_table.

    CALL METHOD super->if_multiple_model_holder_mm~set_current_model(
      im_model ).

*    mmpur_dynamic_cast l_model im_model.

*    READ TABLE my_table INTO ls_data WITH KEY objref = l_model.

*    IF sy-subrc IS INITIAL.
    mmpur_begin_mutex current_model.

    my_current_model = im_model.

    RAISE EVENT if_subject_mm~changed.

    mmpur_end_mutex current_model.
*    ENDIF.

  ENDMETHOD. "if_multiple_model_holder_mm~set_current_model

  METHOD if_multiple_model_holder_mm~next.

    DATA: l_index TYPE sy-tabix,
          l_lines TYPE sy-tfill,
          ls_mytable LIKE LINE OF my_table,
          l_req_item TYPE REF TO if_purchase_requisition_item.

    IF NOT my_current_model IS INITIAL.

      l_req_item ?= my_current_model.

      DESCRIBE TABLE my_table LINES l_lines.

      READ TABLE my_table WITH KEY objref = l_req_item
        TRANSPORTING NO FIELDS.

      IF sy-subrc EQ 0 AND
         sy-tabix < l_lines.

        l_index = sy-tabix + 1.

        READ TABLE my_table INTO ls_mytable INDEX l_index.

        IF sy-subrc EQ 0 AND
           NOT ls_mytable-objref IS INITIAL.

          CALL METHOD if_multiple_model_holder_mm~set_current_model(
            ls_mytable-objref ).
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "if_multiple_model_holder_mm~next

  METHOD if_multiple_model_holder_mm~previous.

    DATA: l_index TYPE sy-tabix,
          l_lines TYPE sy-tfill,
          ls_mytable LIKE LINE OF my_table,
          l_req_item TYPE REF TO if_purchase_requisition_item.

    IF NOT my_current_model IS INITIAL.

      l_req_item ?= my_current_model.

      READ TABLE my_table WITH KEY objref = l_req_item
        TRANSPORTING NO FIELDS.

      IF sy-subrc EQ 0 AND
         sy-tabix > 1.

        l_index = sy-tabix - 1.

        READ TABLE my_table INTO ls_mytable INDEX l_index.

        IF sy-subrc EQ 0 AND
           NOT ls_mytable-objref IS INITIAL.

          CALL METHOD if_multiple_model_holder_mm~set_current_model(
            ls_mytable-objref ).
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "if_multiple_model_holder_mm~previous

  METHOD if_multiple_model_holder_mm~get_models.

    DATA: ls_model LIKE LINE OF re_models.

    FIELD-SYMBOLS: <fs_mytable> LIKE LINE OF my_table.

    LOOP AT my_table ASSIGNING <fs_mytable>.

      ls_model-model = <fs_mytable>-objref.

      APPEND ls_model TO re_models.

    ENDLOOP.

  ENDMETHOD.                    "if_multiple_model_holder_mm~get_models

  METHOD assign_source_of_supply.

    DATA: lt_models        TYPE mmpur_models,
          ls_models        LIKE LINE OF lt_models,
          l_req            TYPE REF TO if_purchase_requisition_item,
          l_source_manager TYPE REF TO cl_source_manager_mm.

    CHECK my_changeable EQ mmpur_yes.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    l_source_manager = cl_source_manager_mm=>get_instance( ).

    LOOP AT lt_models INTO ls_models.

      mmpur_dynamic_cast l_req ls_models-model.

      CHECK NOT l_req IS INITIAL.

      CALL METHOD l_source_manager->search( im_bo = l_req ).

    ENDLOOP.
* sync gui framework
    CALL METHOD transport_from_model( my_model ).
    CALL METHOD if_multiple_model_holder_mm~set_current_model(
      my_current_model ).

  ENDMETHOD.                    "assign_source_of_supply

*----------------------------------------------------------------------*

  METHOD get_proposer_data.

    DATA: l_ref         TYPE REF TO data,
          l_header      TYPE mereq_header.

    FIELD-SYMBOLS: <data> TYPE mereq_prop.

    CHECK my_changeable EQ mmpur_yes.

    IF NOT my_proposer IS INITIAL.

      CALL METHOD my_proposer->if_dataprovider_mm~get_data
        IMPORTING
          ex_data = l_ref.

      ASSIGN l_ref->* TO <data>.
* transport information into my_proposed_item
      CLEAR my_proposed_item.
      MOVE-CORRESPONDING <data> TO my_proposed_item.
      CALL FUNCTION 'PERIOD_AND_DATE_CONVERT_INPUT'
        EXPORTING
          external_date              = <data>-eeind
          external_period            = <data>-elpei
          dialog_date_is_in_the_past = space
        IMPORTING
          internal_date              = my_proposed_item-lfdat
          internal_period            = my_proposed_item-lpein
        EXCEPTIONS
          error_message              = 1
          OTHERS                     = 2.
      IF NOT sy-subrc IS INITIAL.
        CLEAR: my_proposed_item-lfdat, my_proposed_item-lpein.
        DATA: l_tprg            TYPE tprg.
        IF NOT <data>-elpei IS INITIAL.
          SELECT SINGLE * FROM tprg INTO l_tprg WHERE
                             spras = sy-langu AND
                             prgbz = <data>-elpei.
          IF sy-subrc IS INITIAL.
            my_proposed_item-lpein = l_tprg-prgrs.
          ENDIF.
        ENDIF.
      ENDIF.

* get a value for the document type on item level
      IF NOT my_req IS INITIAL.
        l_header = my_req->get_data( ).
        my_proposed_item-bsart = l_header-bsart.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "get_proposer_data

***DCM
  METHOD process_banpr.
    DATA: l_item        TYPE mereq_item,
          l_releasable  TYPE REF TO if_releasable_mm,
          l_buyer       TYPE REF TO if_buyers_approval_mm,
          l_dcm_adapter TYPE REF TO if_dcm_adapter,
          l_dcm         TYPE REF TO if_revision_manager_dcm,
          lt_models     TYPE mmpur_models,
          ls_model      LIKE LINE OF lt_models,
          l_flush       TYPE REF TO if_flush_transport_mm.

    CHECK NOT im_req_item IS INITIAL.
    l_item = im_req_item->get_data( ).
    CASE l_item-banpr.

      WHEN cl_process_state_mm=>c_rejected.
        mmpur_dynamic_cast l_releasable im_req_item.
        IF NOT l_releasable IS INITIAL.
          IF l_releasable->is_reset_rej_allowed( ) EQ mmpur_yes.
            CALL METHOD l_releasable->reject
              EXPORTING
                im_reset = mmpur_yes
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s818(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_buyer_rejected.
        mmpur_dynamic_cast l_buyer im_req_item.
        IF NOT l_buyer IS INITIAL.
          IF l_buyer->is_reset_rej_allowed( ) EQ mmpur_yes.
            CALL METHOD l_buyer->reject
              EXPORTING
                im_reset = mmpur_yes
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s803(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_final_approval.
        mmpur_dynamic_cast l_buyer im_req_item.
        IF NOT l_buyer IS INITIAL.
          IF l_buyer->is_acceptance_allowed( ) EQ mmpur_yes.
            CALL METHOD l_buyer->accept
              EXPORTING
                im_reset = mmpur_no
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s809(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_release_active.
        mmpur_dynamic_cast l_releasable im_req_item.
        IF NOT l_releasable IS INITIAL.
          IF l_releasable->is_release_allowed( ) EQ mmpur_yes.
            CALL METHOD l_releasable->initiate_release
              EXPORTING
                im_reset = mmpur_no
                im_all   = mmpur_yes
              EXCEPTIONS
                failed   = 01.
            IF sy-subrc EQ 1.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              MESSAGE s804(mepo).
            ENDIF.
          ENDIF.
        ENDIF.

      WHEN cl_process_state_mm=>c_revision_active.
        mmpur_dynamic_cast l_dcm_adapter im_req_item.
        IF NOT l_dcm_adapter IS INITIAL
        AND l_dcm_adapter->is_complete_version_allowed( ) EQ mmpur_yes.
          l_dcm = l_dcm_adapter->get_manager( ).
          IF NOT l_dcm IS INITIAL.
            CALL METHOD l_dcm->complete_item( ).
            CALL METHOD notify_data_changed( im_req_item ).
            l_flush ?=
               im_req_item->if_flush_transport_mm~can_initiate_flush( ).
            ls_model-model = im_req_item.
            APPEND ls_model TO lt_models.
            CALL METHOD l_flush->start
              EXPORTING
                im_models = lt_models
              EXCEPTIONS
                OTHERS    = 0.
          ENDIF.
        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "process_banpr
*
*.. complete versions in all selected items
  METHOD complete_version_all.
    DATA: lt_models      TYPE mmpur_models,
          ls_models      LIKE LINE OF lt_models,
          l_fcode        TYPE sy-ucomm VALUE 'DUMMY',
          ls_mereqitem   TYPE mereq_item,
          l_req          TYPE REF TO if_purchase_requisition_item.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_models.
      mmpur_dynamic_cast l_req ls_models-model.
      CHECK NOT l_req IS INITIAL.

      ls_mereqitem = l_req->get_data( ).
      IF ls_mereqitem-banpr EQ cl_process_state_mm=>c_revision_active.
        CALL METHOD process_banpr( l_req ).
      ENDIF.

      CALL METHOD notify_data_changed( ls_models-model ).

      IF l_fcode IS INITIAL.
        EXIT.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "complete_version_all

  METHOD release_set_selection.

    DATA: ls_data      LIKE LINE OF my_table,
          l_releasable TYPE REF TO if_releasable_mm,
          lt_models    TYPE mmpur_models,
          ls_model     LIKE LINE OF lt_models.

    my_release_filter_on = im_release_filter.

    CALL METHOD transport_from_model( my_req ).

  ENDMETHOD.                    "release_set_selection

  METHOD release_selection.

    DATA: lt_models      TYPE mmpur_models,
          ls_model       LIKE LINE OF lt_models,
          l_releasable   TYPE REF TO if_releasable_mm,
          ls_mereqitem   TYPE mereq_item,
          l_req          TYPE REF TO if_purchase_requisition_item.

    CALL METHOD get_selection
      IMPORTING
        ex_models = lt_models.

    IF lt_models IS INITIAL.
      MESSAGE s103(06).
      EXIT.
    ENDIF.

    LOOP AT lt_models INTO ls_model.

      mmpur_dynamic_cast l_req ls_model-model.
      CHECK NOT l_req IS INITIAL.

      mmpur_dynamic_cast l_releasable ls_model-model.
      CHECK NOT l_releasable IS INITIAL.

      ls_mereqitem = l_req->get_data( ).
      IF ls_mereqitem-banpr EQ cl_process_state_mm=>c_release_active.
        CALL METHOD process_banpr( l_req ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "release_selection

ENDCLASS.                    "lcl_req_item_grid IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_catalog IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_catalog IMPLEMENTATION.

  METHOD get_instance.
* define local data objects
    DATA: ls_entry TYPE lcl_catalog=>type_s_instance.

    IF io_model IS INITIAL OR io_parent IS INITIAL.
      RETURN.
    ENDIF.
    READ TABLE lcl_catalog=>gt_instances
               WITH TABLE KEY model  = io_model
                              parent = io_parent
                         INTO ls_entry.
    IF sy-subrc GT 0. "not found
      CLEAR ls_entry.
      ls_entry-model = io_model.
      ls_entry-parent ?= io_parent.
      CREATE OBJECT ls_entry-catalog
        EXPORTING
          io_model  = io_model
          io_parent = io_parent.
      INSERT ls_entry INTO TABLE lcl_catalog=>gt_instances.
    ENDIF.
    ro_catalog = ls_entry-catalog.
  ENDMETHOD.                    "get_instance

  METHOD constructor.
    DATA: lo_preq  TYPE REF TO if_purchase_requisition_item,
          lo_po    TYPE REF TO cl_po_item_handle_mm,
          lo_alv   TYPE REF TO cl_grid_view_mm,
          lo_table TYPE REF TO cl_table_view_mm,
          lr_data  TYPE REF TO data,
          lr_table TYPE REF TO data.
    TYPE-POOLS abap.
    me->mo_const = cl_mmpur_constants=>get_instance( ).
    me->mo_model = io_model.
    mmpur_dynamic_cast1 lo_alv io_parent.
    IF lo_alv IS INITIAL.
      mmpur_dynamic_cast1 lo_table io_parent.
      IF lo_table IS INITIAL.
        RETURN.
      ENDIF.
    ELSE.
      me->mv_alv = me->mo_const->yes.
    ENDIF.
    me->mv_ehp5 = cl_ops_switch_check=>mm_sfws_cat_int( ).
* set document type
*  a) Purchase Requisition
    IF me->is_preq( me->mo_model ) EQ me->mo_const->yes.
      me->mv_bstyp = me->mo_const->bstyp_b.
      me->mv_struc = me->lif_catalog~mc_mereq_item.
*   a1) item overview as ALV Grid
      IF me->mv_alv EQ me->mo_const->yes.
        me->mv_ddic = me->lif_catalog~mc_req_grid.
        CREATE DATA:
          lr_data  TYPE me->lif_catalog~type_s_pr_grid,
          lr_table TYPE me->lif_catalog~type_t_pr_grid.
      ELSE.
*   a2) item overview as table control
        me->mv_ddic = me->lif_catalog~mc_req_table.
        CREATE DATA:
          lr_data  TYPE me->lif_catalog~type_s_pr_table,
          lr_table TYPE me->lif_catalog~type_t_pr_table.
      ENDIF.
    ELSE.
*  b) Purchase Order
      me->mv_bstyp = me->mo_const->bstyp_f.
      me->mv_struc = me->lif_catalog~mc_mepo_item.
*   b1) item overview as ALV Grid
      IF me->mv_alv EQ me->mo_const->yes.
        me->mv_ddic = me->lif_catalog~mc_po_grid.
        CREATE DATA:
          lr_data  TYPE me->lif_catalog~type_s_po_grid,
          lr_table TYPE me->lif_catalog~type_t_po_grid.
      ELSE.
*   b2) item overview as table control
        me->mv_ddic = me->lif_catalog~mc_po_table.
        CREATE DATA:
          lr_data  TYPE me->lif_catalog~type_s_po_table,
          lr_table TYPE me->lif_catalog~type_t_po_table.
      ENDIF.
    ENDIF.
* define catalog item type via Runtime Type Services
    me->mo_cat_struc ?= cl_abap_typedescr=>describe_by_data_ref( lr_data ).
    me->mo_cat_table ?= cl_abap_typedescr=>describe_by_data_ref( lr_table ).
*
* get own logical system
    CALL FUNCTION 'OWN_LOGICAL_SYSTEM_GET'
      IMPORTING
        own_logical_system             = me->mv_logsy
      EXCEPTIONS
        own_logical_system_not_defined = 1
        OTHERS                         = 2.
    IF sy-subrc GE 1.
      CLEAR me->mv_logsy.
    ENDIF.

  ENDMETHOD.                    "constructor

*--------------------------------------------------------------------*
* Read from catalog into target element
*--------------------------------------------------------------------*
  METHOD read_from_catalog.
* define local data objects
    DATA: lo_mfs   TYPE REF TO cl_mfs_mm,
          lo_ibs   TYPE REF TO me_catalog_interface,
          lo_cust  TYPE REF TO me_catalog_interface_cust,
          lo_mmbsi TYPE REF TO cl_mmbsi_cc_conv,
          lo_rtts  TYPE REF TO cl_abap_structdescr,
          lr_item  TYPE REF TO mmpur_oci_cat_return_type,
          lr_oci   TYPE REF TO mmpur_oci_cat_return_type,
          lr_data  TYPE REF TO data,
          lr_prop  TYPE REF TO data,
          lo_obj   TYPE REF TO object,

          ls_fieldsel      TYPE mmpur_fs,

          lt_oci_item      TYPE mmpur_oci_cat_return_type_t,
          lt_oci_longtext  TYPE wsi_oci_longtext_t,
          lt_map_fields    TYPE mecat_fieldmap_tab,
          lt_mapping       TYPE mepo_t_metafield_mapping,

          lv_error         TYPE c LENGTH 1,
          lv_srm           TYPE c LENGTH 1,
          lv_found         TYPE i.

    FIELD-SYMBOLS:
              <lo_req>  TYPE REF TO if_purchase_requisition_item,
              <lo_po>   TYPE REF TO cl_po_item_handle_mm,
              <lt_tab>  TYPE STANDARD TABLE,
              <ls_prop> TYPE any,
              <ls_data> TYPE any,
              <lv_any>  TYPE any.
    DEFINE map.
      translate &2 to upper case.                           "#EC *
      me->map_data( exporting iv_field = &2
                              iv_value = &3
                    changing  cs_data  = &1 ).
    END-OF-DEFINITION.
*
* assign data references to field symbols by using RTTS handle types
    CREATE DATA: lr_data TYPE HANDLE me->mo_cat_struc,
                 lr_prop TYPE HANDLE me->mo_cat_struc.
    ASSIGN:
      lr_data->*    TO <ls_data> CASTING TYPE HANDLE me->mo_cat_struc,
      lr_prop->*    TO <ls_prop> CASTING TYPE HANDLE me->mo_cat_struc,
      im_item_table TO <lt_tab>  CASTING TYPE HANDLE me->mo_cat_table.
*
**   get proposed data for new items and ...
    IF me->mv_alv EQ me->mo_const->yes.
      IF me->is_preq( me->mo_model ) EQ abap_true.
        ASSIGN COMPONENT 'DATA-OBJREF' OF STRUCTURE <ls_data> TO <lo_req>.
        lo_obj ?= <lo_req>.
      ELSE.
        ASSIGN COMPONENT 'DATA-OBJREF' OF STRUCTURE <ls_data> TO <lo_po>.
        lo_obj ?= <lo_po>.
      ENDIF.
*      READ TABLE <lt_tab> INTO <ls_prop> WITH KEY data-objref = lo_obj.
**   ... delete entry for proposer from out_tab
*      IF sy-tabix GT 0.
*        DELETE <lt_tab> INDEX sy-tabix.
*      ENDIF.
    ELSE.
*      ASSIGN COMPONENT 'MODEL' OF STRUCTURE <ls_data> TO <lo_obj>.
*      READ TABLE <lt_tab> INTO <ls_prop>
*                               WITH KEY model = <lo_obj>.
*   ... delete entry for proposer from out_tab
*      IF sy-tabix GT 0.
*        DELETE <lt_tab> INDEX sy-tabix.
*      ENDIF.
    ENDIF.

* call catalog interface
*    TRY.
*        CALL FUNCTION 'MMPUROCI_PRODUCT_SEARCH'
*          EXPORTING
*            imd_bstyp        = me->mv_bstyp
*            imd_searchstring = ''
*            imd_init_call    = me->mo_const->yes
*          IMPORTING
*            et_oci_items     = lt_oci_item
*            et_oci_longtext  = lt_oci_longtext.
*        IF lines( lt_oci_item ) EQ 0.
*          REFRESH im_item_table.
*          RAISE no_data_import.
*        ENDIF.
*
*      CATCH cx_mmpur_not_found.
*        RAISE illegal_call.
*      CATCH cx_mmpur_incorrect_customizing.
*        RAISE illegal_call.
*    ENDTRY.
**
** build field selection data
*    me->build_fieldsel( ).
**
** map catalog entries
*    LOOP AT lt_oci_item REFERENCE INTO lr_oci.
*      READ TABLE <lt_tab> INDEX sy-tabix REFERENCE INTO lr_item.
*      IF sy-subrc GT 0.
*        CREATE DATA lr_item TYPE HANDLE me->mo_cat_struc.
**        MOVE-CORRESPONDING lr_prop->* TO lr_item->*.
*        data lv_new type mmpur_bool.
*        lv_new     = me->mo_const->yes.
*      ENDIF.
**
** service package integration
*      IF me->mv_ehp5 EQ me->mo_const->yes.
*      ENDIF.
**
** get field selection
**      me->fs_get( ).
**
** process BAdI ES_BADI_ME_CATALOG
*      lo_rtts  ?= cl_abap_structdescr=>describe_by_data( lr_item->* ).
*      TRY.
*          GET BADI lo_ibs.
**          CLEAR: ls_map_fields, lt_map_fields.
*          CALL BADI lo_ibs->map_cat_values
*            EXPORTING
*              im_bstyp                   = me->mv_bstyp
*              im_catalog_structure       = 'ls_oci_item'
*              im_catalog_structure_descr = me->mo_cat_struc
*              im_item_structure          = 'ls_cat_item'
*              im_item_structure_descr    = lo_rtts
*            IMPORTING
*              ex_field_map               = lt_map_fields
*            CHANGING
*              ch_oci_item                = lr_oci->*.
*        CATCH cx_badi_not_implemented.
*      ENDTRY.
** customer badi
*      GET BADI lo_cust.
*      CALL BADI lo_cust->map_catalog_values
*        EXPORTING
*          iv_bstyp             = me->mv_bstyp
*          iv_item_structure    = 'ls_oci_item'
*          iv_catalog_structure = 'ls_cat_item'
*          io_rtts_item         = lo_rtts
*          io_rtts_catalog      = me->mo_cat_struc
*        CHANGING
*          ct_field_map         = lt_map_fields
*          ct_oci_item          = lr_oci->*.
**
** start field mapping
**     service flag
*      IF lr_oci->service EQ me->mo_const->yes OR lr_oci->item_type CA 'OR' AND
*        me->is_input_allowed( 'EPSTP' ) EQ me->mo_const->yes.
**        lr_item->data-pstyp = me->mo_const->pstyp_9.
**        SELECT SINGLE epstp FROM t163y INTO lr_item->data-epstp
**                 WHERE pstyp = lr_item->data-pstyp
**                   AND spras = sy-langu.
*      ENDIF.
**
**     item overview
*      map lr_item->data 'WAERS' lr_oci->currency.
*      IF lr_item->data-pstyp NE me->mo_const->pstyp_9.
*        map lr_item->data 'MATNR' lr_oci->matnr.
*        IF me->is_input_allowed( 'MENGE' ) EQ me->mo_const->yes.
*          CALL FUNCTION 'ME_MAP_CHAR_TO_PACK'
*            EXPORTING
*              im_pack = lr_item->data-menge
*            CHANGING
*              ch_char = lr_oci->quantity
*            EXCEPTIONS
*              OTHERS  = 0.
*          TRY.
*              lr_item->data-menge = lr_oci->quantity.
*            CATCH cx_sy_conversion_error cx_sy_arithmetic_error.
*              MESSAGE i765(me) WITH lr_oci->quantity 'MENGE'.
*              lv_error = me->mo_const->yes.
*          ENDTRY.
*        ENDIF.
** order unit of measure
*        IF me->is_input_allowed( 'MEINS' ) EQ me->mo_const->yes.
*          IF lr_oci->unit IS NOT INITIAL.
*            CALL FUNCTION 'UNIT_OF_MEASURE_ISO_TO_SAP'
*              EXPORTING
*                iso_code  = lr_oci->unit
*              IMPORTING
*                sap_code  = lr_item->data-meins
*              EXCEPTIONS
*                not_found = 1
*                OTHERS    = 2.
*            IF sy-subrc GT 0.
*              MESSAGE i851(me) WITH lr_oci->unit.
*              lv_error = me->mo_const->yes.
*            ENDIF.
*          ELSE.
*            CLEAR lr_item->data-meins.
*          ENDIF.
*        ENDIF.
** valuation price
*        IF me->is_input_allowed( 'PREIS' ) EQ me->mo_const->yes.
**         convert currency amount
*          IF lr_item->data-waers IS NOT INITIAL.
*            CALL FUNCTION 'CURRENCY_CONVERTING_FACTOR'
*              EXPORTING
*                currency = lr_item->data-waers
*              IMPORTING
*                factor   = lv_factor
*              EXCEPTIONS
*                OTHERS   = 1.
*            IF sy-subrc EQ 1.
*              lv_factor = 1.
*            ENDIF.
*          ELSE.
*            lv_factor = 1.
*          ENDIF.
*          TRY.
*              lr_item->data-preis = lr_oci->price * 10 / lv_factor.
*            CATCH cx_sy_conversion_error cx_sy_arithmetic_error.
*              MESSAGE i765(me) WITH lr_oci->price 'PREIS'.
*              lv_error = me->mo_const->yes.
*          ENDTRY.
*        ENDIF.
*        IF lr_oci->priceunit IS INITIAL.
*          lr_oci->priceunit = 1.
*        ENDIF.
*        map lr_item->data 'PEINH' lr_oci->priceunit.
*      ENDIF.
*      map lr_item->data 'TXZ01' lr_oci->description.
*      IF lr_item->data-matnr IS INITIAL.
*        map lr_item->data 'WGBEZ' lr_oci->matgroup.
*      ENDIF.
*      map lr_item->data 'PLIFZ' lr_oci->leadtime.
*      map lr_item->data 'IDNLF' lr_oci->vendormat.
**     source
*      IF l_header_data-bsakz EQ 'T'.
*        map lr_item->data 'RESWK' lr_oci->vendor.
*      ELSE.
*        map lr_item->data 'FLIEF' lr_oci->vendor.
** fill leading zeros.
*        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
*          EXPORTING
*            input  = lr_item->data-flief
*          IMPORTING
*            output = lr_item->data-flief.
*      ENDIF.
*      map lr_item->data 'KONNR' lr_oci->contract.
*      map lr_item->data 'KTPNR' lr_oci->contract_item.
*      map lr_item->data 'INFNR' lr_oci->purchinfrec.
*      map lr_item->data 'EKORG' lr_oci->purchorg.
*
*      " Ehp5 Catalog changes, the contract reference should be done only if the contract was uploaded
*      " from the same system or belongs to a central contract that has been distributed to the current system
*      IF me->mv_ehp5 EQ me->mo_const->yes.
*        IF lr_item->data-pstyp EQ me->mo_const->pstyp_9.
*          ls_proposed_item-data-packno = lv_packno.
*          lr_item->data-packno         = lv_packno.
*        ENDIF.
*        lo_mmbsi = cl_mmbsi_cc_conv=>get_instance( ).
*
*        IF lr_oci->sld_sys_name NE me->mv_logsy.
*
*          CLEAR: lr_item->data-konnr, lr_item->data-ktpnr.
*
*          lv_contract_item = lr_oci->contract_item.
*
*          lo_mmbsi->check_is_srm_contract(
*            EXPORTING iv_contract_id      = lr_oci->contract
*                      iv_contract_item_id = lv_contract_item
*            IMPORTING ev_srm_flag         = lv_srm
*                      ev_srm_contract_id  = lv_srm_contract_id ).
*
*          IF lv_srm EQ me->mo_const->yes.
*            map lr_item->data 'SRM_CONTRACT_ID'  lr_oci->contract.
*            map lr_item->data 'SRM_CONTRACT_ITM' lr_oci->contract_item.
*          ENDIF.
*        ELSE.
*          IF lr_oci->item_type NE 'R'.
*            CLEAR: lr_item->data-konnr, lr_item->data-ktpnr.
*            lv_srvmapkey = lr_oci->contract_item.
*            lo_mmbsi->get_erp_cont_item_id(
*              EXPORTING iv_erp_contract_id      = lr_oci->contract
*                        iv_srvmapkey            = lv_srvmapkey
*              IMPORTING ev_erp_contract_item_id = lv_erp_contract_item ).
*            map lr_item->data 'KONNR' lr_oci->contract.
*            map lr_item->data 'KTPNR' lr_oci->contract_item.
*          ENDIF.
*        ENDIF.
*      ENDIF.
*
**     extra field mapping based on BAdI
*      LOOP AT lt_map_fields INTO ls_map_fields.
*        TRANSLATE ls_map_fields TO UPPER CASE.           "#EC TRANSLANG
*        CASE ls_map_fields-item_field.
*          WHEN 'WERKS'.
*            ls_map_fields-item_field = 'NAME1'.
*          WHEN 'RESWK'.
*            ls_map_fields-item_field = 'RESWK_BEZ'.
*          WHEN 'LGORT'.
*            ls_map_fields-item_field = 'LGOBE'.
*          WHEN 'MATKL'.
*            ls_map_fields-item_field = 'WGBEZ'.
*          WHEN 'PSTYP'.
*            ls_map_fields-item_field = 'EPSTP'.
*          WHEN 'RESLO'.
*            ls_map_fields-item_field = 'RESLO_BEZ'.
*          WHEN 'NETPR'.
*            CONTINUE.
*        ENDCASE.
*        IF me->mv_ehp5 EQ me->mo_const->no.
*          CASE ls_map_fields-catalog_field.
*            WHEN 'CONTRACT'.
*              CONTINUE.
*            WHEN 'CONTRACT_ITEM'.
*              CONTINUE.
*          ENDCASE.
*        ENDIF.
*
*        ASSIGN COMPONENT ls_map_fields-catalog_field OF STRUCTURE lr_oci->* TO <source>.
*        CHECK sy-subrc IS INITIAL.
*        LOOP AT l_item_descr->components ASSIGNING <mapping>.
*          ASSIGN COMPONENT <mapping>-name OF STRUCTURE ls_cat_item TO <s_target>.
*          CHECK sy-subrc IS INITIAL.
*          ASSIGN COMPONENT ls_map_fields-item_field OF STRUCTURE <s_target> TO <target>.
*          CHECK sy-subrc IS INITIAL.
*          TRY.
*              CALL FUNCTION 'ME_MAP_CHAR_TO_PACK'
*                EXPORTING
*                  im_pack = <target>
*                CHANGING
*                  ch_char = <source>
*                EXCEPTIONS
*                  OTHERS  = 1.
*              map <s_target> ls_map_fields-item_field <source>.
*            CATCH cx_sy_conversion_error cx_sy_arithmetic_error.
*              MESSAGE i765(me) WITH <source> ls_map_fields-item_field.
*              lv_error = me->mo_const->yes.
*          ENDTRY.
*        ENDLOOP.
*      ENDLOOP.
*
**     text
*      is_input_allowed 'ITEXT'.
*      IF me->is_input_allowed( 'ITEXT' ) EQ me->mo_const->yes.
*        LOOP AT lt_oci_longtext INTO  ls_oci_longtext
*                                WHERE line EQ lr_oci->line.
*          ls_textline-tdobject  = 'EBAN'.
*          ls_textline-tdid      = l_tdid.
*          ls_textline-tdformat  = ls_oci_longtext-text_form.
*          ls_textline-tdline    = ls_oci_longtext-text_line.
*          INSERT ls_textline INTO TABLE lr_item->text.
*        ENDLOOP.
*      ENDIF.
*
*      IF lv_new EQ me->mo_const->yes.
*        INSERT lr_item->* INTO TABLE im_item_table.
*      ENDIF.
*    ENDLOOP.
  ENDMETHOD.                    "read_from_catalog

*--------------------------------------------------------------------*
* Is reference object a PReq?
*--------------------------------------------------------------------*
  METHOD is_preq.
    DATA lo_preq TYPE REF TO if_purchase_requisition.
    mmpur_dynamic_cast1 lo_preq me->mo_model.
    IF lo_preq IS BOUND.
      rv_preq = me->mo_const->yes.
    ELSE.
      rv_preq = me->mo_const->no.
    ENDIF.
  ENDMETHOD.                    "is_preq

*--------------------------------------------------------------------*
* Build Field Selection
*--------------------------------------------------------------------*
  METHOD build_fieldsel.
* define local data objects
    DATA: lo_mfs      TYPE REF TO cl_mfs_mm,
          ls_fieldsel TYPE mmpur_fs,
          lt_mapping  TYPE mepo_t_metafield_mapping.
    FIELD-SYMBOLS:
          <ls_mapping> TYPE mepo_s_metafield_mapping.

*  get mapping for fieldselection
*    IF lines( me->mt_mapping ) EQ 0.
*      lo_mfs = cl_mfs_mm=>get_instance( ).
*      lo_mfs->register( EXPORTING  im_application = 'MMPUR_PO_VIEWS'
*                        EXCEPTIONS already_registered = 0
*                                   failure            = 0 ).
*      me->mt_mapping = lo_mfs->lookup( im_application = 'MMPUR_PO_VIEWS'
*                                       im_tabname     = me->mv_ddic ).
*      lo_mfs->register( EXPORTING  im_application = 'MMPUR_PO_DOC'
*                        EXCEPTIONS already_registered = 0
*                                   failure            = 0 ).
*      lt_mapping = lo_mfs->lookup( im_application = 'MMPUR_PO_DOC'
*                                   im_tabname     = me->mv_sturc
*                                   im_fieldname   = 'ITEXT' ).
*      LOOP AT lt_mapping ASSIGNING <ls_mapping>.
*        READ TABLE me->mt_mapping
*                   WITH TABLE KEY application = <ls_mapping>-application
*                                  tabname     = <ls_mapping>-tabname
*                                  fieldname   = <ls_mapping>-fieldname
*                   TRANSPORTING NO FIELDS.
*        CHECK sy-subrc GT 0.
*        INSERT <ls_mapping> INTO TABLE me->mt_mapping.
*        EXIT.
*      ENDLOOP.
*      LOOP AT me->mt_mapping ASSIGNING <ls_mapping>.
*        ls_fs-metafield = <ls_mapping>-metafield.
*        INSERT ls_fs INTO TABLE me->mt_fieldsel.
*      ENDLOOP.
*    ENDIF.

  ENDMETHOD.                    "build_fieldsel

*--------------------------------------------------------------------*
* Get field selection attributes
*--------------------------------------------------------------------*
  METHOD fs_get.
* define local data objects
    DATA: lr_data TYPE REF TO data,
          lo_fs   TYPE REF TO if_fieldselection_mm.

    IF ir_data IS INITIAL.
      RETURN.
    ENDIF.
    CREATE DATA lr_data TYPE HANDLE me->mo_cat_struc.
    TRY.
        lr_data ?= ir_data.
      CATCH cx_sy_move_cast_error.
        CLEAR lr_data.
        RETURN.
    ENDTRY.
    IF me->mv_alv EQ me->mo_const->yes.
*      lo_fs ?= lr_data->data-objref.
    ELSE.
*      lo_fs ?= lr_data->model.
    ENDIF.
    lo_fs->fs_get( CHANGING ch_fieldselection = mt_fieldsel ).
  ENDMETHOD.                    "fs_get

*--------------------------------------------------------------------*
* Map field value from catalog into communication structure
*--------------------------------------------------------------------*
  METHOD map_data.
* define local data objects
    FIELD-SYMBOLS: <lv_value> TYPE any.
*
    IF me->is_input_allowed( iv_field ) EQ me->mo_const->no.
      RETURN.
    ENDIF.
    ASSIGN COMPONENT iv_field OF STRUCTURE cs_data TO <lv_value>.
    IF sy-subrc IS INITIAL AND <lv_value> IS ASSIGNED.
      TRY.
          <lv_value> = iv_value.
        CATCH cx_sy_conversion_overflow.
          CLEAR <lv_value>.
        CATCH cx_sy_conversion_no_number.
          CLEAR <lv_value>.
      ENDTRY.
    ENDIF.

  ENDMETHOD.                    "map_data

*--------------------------------------------------------------------*
* check if data input is allowed
*--------------------------------------------------------------------*
  METHOD is_input_allowed.
    FIELD-SYMBOLS:
          <ls_mapping>  TYPE mepo_s_metafield_mapping,
          <ls_fieldsel> TYPE mmpur_fs.

    rv_allowed = me->mo_const->no.
    IF iv_field IS INITIAL.
      RETURN.
    ENDIF.
    READ TABLE me->mt_mapping ASSIGNING <ls_mapping>
                               WITH KEY fieldname = iv_field.
    IF sy-subrc EQ 0.
      READ TABLE me->mt_fieldsel ASSIGNING <ls_fieldsel>
                                 WITH KEY metafield = <ls_mapping>-metafield.
      IF sy-subrc EQ 0.
        IF ( <ls_fieldsel>-fieldstatus NE me->mo_const->fs_mandatory OR
             <ls_fieldsel>-fieldstatus NE me->mo_const->fs_optional OR
             <ls_fieldsel>-fieldstatus IS NOT INITIAL ).
          rv_allowed = me->mo_const->yes.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "is_input_allowed

ENDCLASS.                    "lcl_catalog IMPLEMENTATION
